# Plan 10: E2E Tests, CI/CD Finalization & Documentation

**Branch**: `feat/e2e-tests-ci-docs`
**PR Title**: `Plan 10: E2E tests, CI/CD finalization, and documentation`
**Created**: 2026-02-11 16:32:14

---

## Overview

This is the final plan (10 of 10) for the Android Remote Control MCP project. It establishes the E2E test module with Testcontainers and Docker Android, implements the Calculator E2E test (7 + 3 = 10) along with additional E2E scenarios, finalizes the CI/CD pipeline with all jobs, adds Jacoco coverage integration, and completes the README.md with full documentation.

### Dependencies on Previous Plans

- **Plan 1**: Project scaffolding, Gradle build system, all dependencies in `libs.versions.toml` (Testcontainers, JUnit 5, OkHttp), `Makefile` with all targets (including `test-e2e`, `coverage`), `.github/workflows/ci.yml` (stub CI with lint + test-unit + build, integration and E2E commented out), `settings.gradle.kts` (includes `:app` only), `README.md` skeleton
- **Plan 2**: `ServerConfig`, `SettingsRepository`, `Logger`, `PermissionUtils`, `NetworkUtils`
- **Plan 3**: `MainViewModel`, `MainActivity`, Compose UI
- **Plan 4**: `McpAccessibilityService`, `AccessibilityTreeParser`, `ElementFinder`, `ActionExecutor`
- **Plan 5**: `ScreenCaptureService`, `ScreenshotEncoder`
- **Plan 6**: `McpServer`, `McpServerService`, `McpProtocolHandler`, `BearerTokenAuth`, `CertificateManager`, `BootCompletedReceiver`, `docs/ARCHITECTURE.md`
- **Plan 7**: `ScreenIntrospectionTools` (4 tools), `SystemActionTools` (6 tools), `ToolRegistry`
- **Plan 8**: `TouchActionTools` (5 tools), `GestureTools` (2 tools)
- **Plan 9**: `ElementActionTools` (5 tools), `TextInputTools` (3 tools), `UtilityTools` (4 tools), `docs/MCP_TOOLS.md`

### Package Base

`com.danielealbano.androidremotecontrolmcp`

### Path References

- **App source root**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/`
- **App test root**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/`
- **E2E test root**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/`
- **CI workflow**: `.github/workflows/ci.yml`

### Key Technical Decisions

1. **E2E module is JVM-only (not Android)**: The E2E tests run on the host machine and connect to the MCP server over the network. This module uses `kotlin("jvm")` plugin, not Android plugins.
2. **Testcontainers with Docker Android**: Uses `budtmo/docker-android-x86:emulator_14.0` image which provides a full Android emulator inside Docker.
3. **Self-signed certificate handling**: OkHttp in E2E tests uses a custom `TrustManager` that trusts all certificates. This is acceptable ONLY for testing; the trust-all manager is confined to the E2E test module.
4. **Shared container singleton**: Uses `SharedAndroidContainer` singleton object to share a single Docker container across ALL E2E test classes (Calculator, Screenshot, ErrorHandling). The container is lazily initialized on first access and stopped via a JVM shutdown hook. This avoids the ~2-4 minute container boot penalty per test class, reducing total E2E runtime from ~10-15 minutes to ~5-7 minutes.
5. **Calculator app flexibility**: The AOSP Calculator app may have different element text/resource IDs across Android versions. Tests use flexible matching (contains search, fallback strategies) to be resilient.
6. **Jacoco plugin**: Added to `app/build.gradle.kts` with HTML + XML reports and 80% minimum coverage verification.
7. **`gh act` limitations**: `gh act` (nektos/act) cannot fully run Android emulator or Docker-in-Docker jobs locally. The CI pipeline documents this limitation; local testing uses `gh act -n push` for dry-run validation.

### Dependency Versions

All versions reference `gradle/libs.versions.toml` from Plan 1. The E2E module uses:
- `testcontainers` = `1.20.4` (verify latest at implementation time)
- `junit5` = `5.11.4` (verify latest at implementation time)
- `kotlinx-serialization` = `1.7.3` (verify latest at implementation time)
- `kotlinx-coroutines` = `1.9.0` (verify latest at implementation time)
- OkHttp = `4.12.0` (new dependency, verify latest at implementation time; must be added to `libs.versions.toml`)

---

## User Story 1: E2E Test Infrastructure & Calculator Test

**As a** developer or maintainer of the Android Remote Control MCP project
**I want** an automated end-to-end test that starts a Docker Android emulator, installs the app, starts the MCP server, and verifies that I can remotely perform a calculation (7 + 3 = 10) through the MCP protocol
**So that** I can confidently verify the entire stack (MCP client -> HTTPS -> MCP server -> accessibility service -> Android UI -> result) works correctly in an integrated environment.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] `e2e-tests/build.gradle.kts` exists as a JVM module with Kotlin, JUnit 5, Testcontainers, OkHttp, and Kotlinx Serialization dependencies
- [ ] `settings.gradle.kts` includes `:e2e-tests` module
- [ ] `McpClient` test utility handles HTTPS with self-signed certs, bearer token auth, and JSON-RPC 2.0 request/response
- [ ] `McpClient.healthCheck()` calls `GET /health` and returns parsed JSON
- [ ] `McpClient.initialize()` sends `initialize` JSON-RPC request
- [ ] `McpClient.listTools()` sends `tools/list` and returns tools array
- [ ] `McpClient.callTool()` sends `tools/call` with name and arguments and returns result
- [ ] `McpClient` handles error responses and throws descriptive exceptions
- [ ] `AndroidContainerSetup` starts `budtmo/docker-android-x86:emulator_14.0` container with adb (5555) and MCP (8080) ports exposed
- [ ] `AndroidContainerSetup` waits for emulator boot completion before returning
- [ ] `AndroidContainerSetup` sets up adb port forwarding from container to emulator (`adb forward tcp:8080 tcp:8080`)
- [ ] `E2EConfigReceiver` debug-only BroadcastReceiver exists at `app/src/debug/kotlin/.../debug/E2EConfigReceiver.kt` (accepts test config via `adb shell am broadcast`)
- [ ] Debug-only `AndroidManifest.xml` overlay at `app/src/debug/AndroidManifest.xml` registers `E2EConfigReceiver`
- [ ] `AndroidContainerSetup` installs APK, enables accessibility service, configures server settings via broadcast (using `E2EConfigReceiver`), and starts MCP server (activity + explicit startservice)
- [ ] `AndroidContainerSetup` polls `GET /health` endpoint until HTTP 200 with `"healthy"` status or timeout (default 60s)
- [ ] `SharedAndroidContainer` singleton manages a single container shared across ALL E2E test classes
- [ ] `SharedAndroidContainer` lazily initializes the container on first access with full setup (boot, port forward, install, config, start, health check)
- [ ] `SharedAndroidContainer` registers a JVM shutdown hook to stop the container when tests complete
- [ ] `E2ECalculatorTest` performs 7 + 3 = 10 calculation end-to-end via MCP tools and verifies result "10" in the accessibility tree
- [ ] `E2ECalculatorTest` captures a screenshot during the test and verifies non-empty base64 data
- [ ] All E2E test classes use `SharedAndroidContainer` singleton (no per-class container lifecycle)
- [ ] OkHttp `libs.versions.toml` entry added for the E2E module dependency
- [ ] `make lint` passes with no errors or warnings
- [ ] `make test-unit` passes (E2E module has no unit test impact on app module)
- [ ] `make build` succeeds with no errors or warnings
- [ ] `make test-e2e` passes (if Docker is available)

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 1 | `chore: add E2E test module with Testcontainers configuration` | `e2e-tests/build.gradle.kts`, updated `settings.gradle.kts`, updated `gradle/libs.versions.toml`, `McpClient.kt`, `AndroidContainerSetup.kt`, `SharedAndroidContainer.kt`, `E2EConfigReceiver.kt`, `app/src/debug/AndroidManifest.xml` |
| 2 | `test: add Calculator E2E test (7 + 3 = 10)` | `E2ECalculatorTest.kt` |

---

### Task 10.1: Add OkHttp Dependency to Version Catalog

**Description**: Add the OkHttp library to `gradle/libs.versions.toml` so the E2E test module can use it for HTTP requests.

**Acceptance Criteria**:
- [ ] `okhttp` version entry added to `[versions]` section
- [ ] `okhttp` library entry added to `[libraries]` section
- [ ] Version is latest stable (4.12.0, verify at implementation time)

**Tests**: Build verification at end of user story.

#### Action 10.1.1: Update `gradle/libs.versions.toml` with OkHttp

**What**: Add OkHttp version and library entries to the version catalog.

**Context**: OkHttp is used by the E2E test module for making HTTP/HTTPS requests to the MCP server running inside the Docker Android container. It is not used by the main app module (which uses Ktor server-side). OkHttp provides flexible TLS configuration needed for trusting self-signed certificates in tests.

**File**: `gradle/libs.versions.toml`

```diff
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ [versions] section, after the existing test versions (e.g., after testcontainers = "1.20.4")
+# HTTP client (E2E tests)
+okhttp = "4.12.0"                          # verify latest at implementation time

@@ [libraries] section, after the existing test libraries (e.g., after testcontainers-junit-jupiter)
+# OkHttp (E2E tests)
+okhttp = { group = "com.squareup.okhttp3", name = "okhttp", version.ref = "okhttp" }
```

---

### Task 10.2: Create E2E Test Module Build Configuration

**Description**: Create the `e2e-tests/build.gradle.kts` file and update `settings.gradle.kts` to include the new module. The E2E module is a JVM-only module (not Android) that runs on the host machine.

**Acceptance Criteria**:
- [ ] `e2e-tests/build.gradle.kts` applies `kotlin("jvm")` and `kotlin("plugin.serialization")` plugins
- [ ] Dependencies include JUnit 5, Testcontainers, OkHttp, Kotlinx Serialization JSON, Kotlinx Coroutines
- [ ] JUnit 5 platform is configured via `tasks.withType<Test> { useJUnitPlatform() }`
- [ ] `settings.gradle.kts` includes `":e2e-tests"` module
- [ ] Module compiles without errors

**Tests**: Build verification at end of user story.

#### Action 10.2.1: Create `e2e-tests/build.gradle.kts`

**What**: Create the Gradle build configuration for the E2E test module.

**Context**: This is a pure JVM module — it does NOT use Android plugins. It runs on the developer's machine (or CI) and connects to the MCP server running inside a Docker Android container over the network. The module only has test sources (no main sources).

**File**: `e2e-tests/build.gradle.kts`

```diff
--- /dev/null
+++ b/e2e-tests/build.gradle.kts
@@ -0,0 +1,38 @@
+plugins {
+    alias(libs.plugins.kotlin.android).apply(false)
+    kotlin("jvm")
+    kotlin("plugin.serialization") version libs.versions.kotlin.get()
+}
+
+java {
+    sourceCompatibility = JavaVersion.VERSION_17
+    targetCompatibility = JavaVersion.VERSION_17
+}
+
+kotlin {
+    jvmToolchain(17)
+}
+
+dependencies {
+    // Testing framework
+    testImplementation(libs.junit.jupiter.api)
+    testImplementation(libs.junit.jupiter.params)
+    testRuntimeOnly(libs.junit.jupiter.engine)
+
+    // Testcontainers
+    testImplementation(libs.testcontainers)
+    testImplementation(libs.testcontainers.junit.jupiter)
+
+    // HTTP client
+    testImplementation(libs.okhttp)
+
+    // Serialization
+    testImplementation(libs.kotlinx.serialization.json)
+
+    // Coroutines
+    testImplementation(libs.kotlinx.coroutines.core)
+    testImplementation(libs.kotlinx.coroutines.test)
+}
+
+tasks.withType<Test> {
+    useJUnitPlatform()
+}
```

> **Implementation Note**: The `alias(libs.plugins.kotlin.android).apply(false)` line may not be needed if the root `build.gradle.kts` already declares it. At implementation time, verify that the `kotlin("jvm")` and `kotlin("plugin.serialization")` plugins resolve correctly. If version catalog plugin aliases are used instead of string-based plugin IDs, adjust accordingly. The key constraint is that this must be a JVM module, not an Android module.

---

#### Action 10.2.2: Update `settings.gradle.kts` to include E2E module

**What**: Add `:e2e-tests` to the module list in `settings.gradle.kts`.

**Context**: The current `settings.gradle.kts` (from Plan 1) includes only `:app`. We need to add `:e2e-tests` so Gradle discovers the E2E test module.

**File**: `settings.gradle.kts`

```diff
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ at the end of the file (after include(":app"))
-include(":app")
+include(":app")
+include(":e2e-tests")
```

---

### Task 10.3: Create MCP Client Test Utility

**Description**: Create `McpClient.kt` — a test utility class that wraps OkHttp to make MCP JSON-RPC 2.0 requests over HTTPS with bearer token authentication and self-signed certificate support.

**Acceptance Criteria**:
- [ ] `McpClient` constructor takes `baseUrl: String` and `bearerToken: String`
- [ ] `McpClient` configures OkHttp with a `TrustAllCerts` TrustManager for self-signed certificates
- [ ] `McpClient` configures OkHttp with a `HostnameVerifier` that accepts all hostnames (testing only)
- [ ] `healthCheck()` sends `GET /health` without bearer token and returns `JsonObject`
- [ ] `initialize()` sends `POST /mcp/v1/initialize` with JSON-RPC 2.0 envelope and returns `JsonObject`
- [ ] `listTools()` sends `POST /mcp/v1/tools/list` with JSON-RPC 2.0 envelope and returns `JsonArray` of tools
- [ ] `callTool(name, arguments)` sends `POST /mcp/v1/tools/call` with JSON-RPC 2.0 envelope and returns result `JsonObject`
- [ ] All authenticated requests include `Authorization: Bearer <token>` header
- [ ] All requests set `Content-Type: application/json`
- [ ] Error responses (HTTP 4xx/5xx) throw `McpClientException` with status code and body
- [ ] JSON-RPC error responses (error field present) throw `McpRpcException` with code and message
- [ ] Request ID auto-increments via `AtomicLong`

**Tests**: Implicitly tested by E2E tests (Task 10.5). No separate unit tests needed for a test utility.

#### Action 10.3.1: Create `McpClient.kt`

**What**: Create the MCP client test utility.

**Context**: This client is used exclusively in E2E tests to communicate with the MCP server running inside the Docker Android container. It handles HTTPS with self-signed certificates (the MCP server auto-generates a self-signed cert on first launch). The trust-all-certs approach is acceptable here because this code is ONLY used in tests and NEVER in production.

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/McpClient.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/McpClient.kt
@@ -0,0 +1,201 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import kotlinx.serialization.json.Json
+import kotlinx.serialization.json.JsonArray
+import kotlinx.serialization.json.JsonElement
+import kotlinx.serialization.json.JsonObject
+import kotlinx.serialization.json.JsonPrimitive
+import kotlinx.serialization.json.buildJsonObject
+import kotlinx.serialization.json.jsonArray
+import kotlinx.serialization.json.jsonObject
+import kotlinx.serialization.json.put
+import kotlinx.serialization.json.putJsonObject
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.toRequestBody
+import java.security.SecureRandom
+import java.security.cert.X509Certificate
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicLong
+import javax.net.ssl.SSLContext
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Exception thrown when the MCP server returns an HTTP error (4xx, 5xx).
+ */
+class McpClientException(
+    val statusCode: Int,
+    val responseBody: String,
+) : RuntimeException("MCP server returned HTTP $statusCode: $responseBody")
+
+/**
+ * Exception thrown when the MCP server returns a JSON-RPC error response.
+ */
+class McpRpcException(
+    val code: Int,
+    override val message: String,
+    val data: JsonElement? = null,
+) : RuntimeException("MCP RPC error $code: $message")
+
+/**
+ * Test utility MCP client for E2E tests.
+ *
+ * Uses OkHttp to make JSON-RPC 2.0 requests to the MCP server over HTTPS.
+ * Trusts all certificates (self-signed) — this is acceptable ONLY for testing.
+ */
+class McpClient(
+    private val baseUrl: String,
+    private val bearerToken: String,
+) {
+    private val json = Json { ignoreUnknownKeys = true }
+    private val requestId = AtomicLong(1)
+    private val client: OkHttpClient
+
+    init {
+        // Create trust-all TrustManager for self-signed certificates (TEST ONLY)
+        val trustAllManager = object : X509TrustManager {
+            override fun checkClientTrusted(chain: Array<out X509Certificate>?, authType: String?) {}
+            override fun checkServerTrusted(chain: Array<out X509Certificate>?, authType: String?) {}
+            override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
+        }
+
+        val sslContext = SSLContext.getInstance("TLS")
+        sslContext.init(null, arrayOf<TrustManager>(trustAllManager), SecureRandom())
+
+        client = OkHttpClient.Builder()
+            .sslSocketFactory(sslContext.socketFactory, trustAllManager)
+            .hostnameVerifier { _, _ -> true }
+            .connectTimeout(30, TimeUnit.SECONDS)
+            .readTimeout(60, TimeUnit.SECONDS)
+            .writeTimeout(30, TimeUnit.SECONDS)
+            .build()
+    }
+
+    /**
+     * Check the /health endpoint (unauthenticated).
+     * Returns the parsed JSON response body.
+     */
+    fun healthCheck(): JsonObject {
+        val request = Request.Builder()
+            .url("$baseUrl/health")
+            .get()
+            .build()
+
+        return executeRequest(request).jsonObject
+    }
+
+    /**
+     * Initialize MCP session.
+     * Returns the JSON-RPC result object.
+     */
+    fun initialize(): JsonObject {
+        val body = buildJsonRpcRequest("initialize")
+        return sendJsonRpc("$baseUrl/mcp/v1/initialize", body)
+    }
+
+    /**
+     * List available MCP tools.
+     * Returns the tools JsonArray from the result.
+     */
+    fun listTools(): JsonArray {
+        val body = buildJsonRpcRequest("tools/list")
+        val result = sendJsonRpc("$baseUrl/mcp/v1/tools/list", body)
+        return result["tools"]?.jsonArray
+            ?: throw McpRpcException(-1, "Response missing 'tools' field")
+    }
+
+    /**
+     * Call an MCP tool by name with optional arguments.
+     * Returns the result content from the JSON-RPC response.
+     */
+    fun callTool(name: String, arguments: Map<String, Any> = emptyMap()): JsonObject {
+        val body = buildJsonObject {
+            put("jsonrpc", "2.0")
+            put("id", requestId.getAndIncrement())
+            put("method", "tools/call")
+            putJsonObject("params") {
+                put("name", name)
+                putJsonObject("arguments") {
+                    arguments.forEach { (key, value) ->
+                        when (value) {
+                            is String -> put(key, value)
+                            is Int -> put(key, value)
+                            is Long -> put(key, value)
+                            is Double -> put(key, value)
+                            is Float -> put(key, value.toDouble())
+                            is Boolean -> put(key, value)
+                            is JsonElement -> put(key, value)
+                            else -> put(key, value.toString())
+                        }
+                    }
+                }
+            }
+        }
+
+        return sendJsonRpc("$baseUrl/mcp/v1/tools/call", body)
+    }
+
+    /**
+     * Build a JSON-RPC 2.0 request envelope with no params.
+     */
+    private fun buildJsonRpcRequest(method: String): JsonObject {
+        return buildJsonObject {
+            put("jsonrpc", "2.0")
+            put("id", requestId.getAndIncrement())
+            put("method", method)
+        }
+    }
+
+    /**
+     * Send a JSON-RPC request to the given URL and parse the result.
+     * Throws [McpRpcException] if the response contains a JSON-RPC error.
+     */
+    private fun sendJsonRpc(url: String, body: JsonObject): JsonObject {
+        val mediaType = "application/json".toMediaType()
+        val requestBody = json.encodeToString(JsonObject.serializer(), body).toRequestBody(mediaType)
+
+        val request = Request.Builder()
+            .url(url)
+            .post(requestBody)
+            .addHeader("Authorization", "Bearer $bearerToken")
+            .addHeader("Content-Type", "application/json")
+            .build()
+
+        val response = executeRequest(request)
+        val responseObj = response.jsonObject
+
+        // Check for JSON-RPC error
+        val error = responseObj["error"]
+        if (error != null) {
+            val errorObj = error.jsonObject
+            val code = errorObj["code"]?.let {
+                (it as? JsonPrimitive)?.content?.toIntOrNull() ?: 0
+            } ?: 0
+            val message = errorObj["message"]?.let {
+                (it as? JsonPrimitive)?.content ?: "Unknown error"
+            } ?: "Unknown error"
+            val data = errorObj["data"]
+            throw McpRpcException(code, message, data)
+        }
+
+        // Return the result field
+        return responseObj["result"]?.jsonObject
+            ?: throw McpRpcException(-1, "Response missing 'result' field")
+    }
+
+    /**
+     * Execute an HTTP request and return parsed JSON.
+     * Throws [McpClientException] for non-2xx responses.
+     */
+    private fun executeRequest(request: Request): JsonElement {
+        client.newCall(request).execute().use { response ->
+            val body = response.body?.string() ?: ""
+
+            if (!response.isSuccessful) {
+                throw McpClientException(response.code, body)
+            }
+
+            return json.parseToJsonElement(body)
+        }
+    }
+}
```

---

### Task 10.4: Create Docker Android Container Setup Utility

**Description**: Create `AndroidContainerSetup.kt` — a test utility object that manages the Docker Android container lifecycle: starting the container, waiting for emulator boot, installing the APK, enabling accessibility, starting the MCP server, and polling the health endpoint.

**Acceptance Criteria**:
- [ ] `createContainer()` creates a `GenericContainer` for `budtmo/docker-android-x86:emulator_14.0`
- [ ] Container exposes ports 5555 (adb) and 6080 (noVNC, optional for debugging) and maps MCP port
- [ ] Container is configured with sufficient memory (at least 4GB) and environment variables for emulator
- [ ] `waitForEmulatorBoot(container, timeoutMs)` polls adb inside the container until `sys.boot_completed` is 1
- [ ] `installApk(container, apkPath)` copies APK into container and installs via `adb install`
- [ ] `enableAccessibilityService(container)` uses `adb shell settings put secure` to enable the accessibility service
- [ ] `startMcpServer(container)` launches the app activity via `adb shell am start`
- [ ] `waitForServerReady(baseUrl, bearerToken, timeoutMs)` polls `/health` endpoint until HTTP 200 or timeout
- [ ] All operations log progress for debugging CI failures
- [ ] Timeout on emulator boot defaults to 180 seconds
- [ ] Timeout on server ready defaults to 60 seconds

**Tests**: Implicitly tested by E2E tests (Task 10.5). No separate unit tests needed for a test utility.

#### Action 10.4.1: Create `AndroidContainerSetup.kt`

**What**: Create the Docker Android container management utility.

**Context**: The `budtmo/docker-android-x86` Docker image provides a full Android emulator inside a Docker container. It exposes adb on port 5555 and noVNC on port 6080. The emulator takes ~60-120 seconds to boot. After boot, we install the APK, enable the accessibility service (via `settings put secure`), and start the MCP server. The MCP server listens on a configurable port (default 8080, but we need to bind to 0.0.0.0 so the host can reach it from outside the container). The port is forwarded via Docker port mapping (Testcontainers handles this automatically with `withExposedPorts`).

Important note on accessibility service enablement via adb: On non-rooted devices, the standard approach is:
```
adb shell settings put secure enabled_accessibility_services <package>/<service-class>
adb shell settings put secure accessibility_enabled 1
```
This works on emulators and adb-connected devices without root.

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/AndroidContainerSetup.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/AndroidContainerSetup.kt
@@ -0,0 +1,249 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import org.testcontainers.containers.GenericContainer
+import org.testcontainers.containers.wait.strategy.Wait
+import org.testcontainers.utility.DockerImageName
+import java.io.File
+import java.time.Duration
+
+/**
+ * Manages the Docker Android container lifecycle for E2E tests.
+ *
+ * Responsibilities:
+ * - Create and configure the Docker Android container
+ * - Wait for emulator boot completion
+ * - Install APK and configure permissions
+ * - Start the MCP server and wait for it to be ready
+ */
+object AndroidContainerSetup {
+
+    private const val DOCKER_IMAGE = "budtmo/docker-android-x86:emulator_14.0"
+    private const val ADB_PORT = 5555
+    private const val NOVNC_PORT = 6080
+    private const val MCP_DEFAULT_PORT = 8080
+
+    private const val APP_PACKAGE = "com.danielealbano.androidremotecontrolmcp.debug"
+    private const val ACCESSIBILITY_SERVICE_CLASS =
+        "com.danielealbano.androidremotecontrolmcp.services.accessibility.McpAccessibilityService"
+    private const val MAIN_ACTIVITY_CLASS =
+        "com.danielealbano.androidremotecontrolmcp.ui.MainActivity"
+
+    private const val DEFAULT_EMULATOR_BOOT_TIMEOUT_MS = 180_000L
+    private const val DEFAULT_SERVER_READY_TIMEOUT_MS = 60_000L
+    private const val POLL_INTERVAL_MS = 2_000L
+    private const val HEALTH_POLL_INTERVAL_MS = 1_000L
+
+    /**
+     * Default bearer token for E2E tests.
+     * The app auto-generates a token on first launch. For E2E testing, we set a known
+     * token via adb shell command after app installation.
+     */
+    const val E2E_BEARER_TOKEN = "e2e-test-token-12345"
+
+    /**
+     * Create a configured Docker Android container.
+     *
+     * The container runs a full Android emulator (API 34, x86) with:
+     * - adb accessible on port 5555
+     * - noVNC accessible on port 6080 (for visual debugging)
+     * - MCP server port exposed and forwarded from the emulator to the container
+     *
+     * Port forwarding chain:
+     *   Test host -> (Testcontainers mapped port) -> Docker container:MCP_DEFAULT_PORT
+     *     -> (adb forward inside container) -> Android emulator:MCP_DEFAULT_PORT
+     *
+     * @return configured [GenericContainer] (not yet started)
+     */
+    fun createContainer(): GenericContainer<*> {
+        println("[E2E Setup] Creating Docker Android container ($DOCKER_IMAGE)")
+
+        return GenericContainer(DockerImageName.parse(DOCKER_IMAGE))
+            .withExposedPorts(ADB_PORT, NOVNC_PORT, MCP_DEFAULT_PORT)
+            .withEnv("EMULATOR_DEVICE", "Samsung Galaxy S10")
+            .withEnv("WEB_VNC", "true")
+            .withEnv("DATAPARTITION_SIZE", "4096")
+            .withPrivilegedMode(true)
+            .withStartupTimeout(Duration.ofSeconds(300))
+            .waitingFor(
+                Wait.forLogMessage(".*Boot completed.*\\n", 1)
+                    .withStartupTimeout(Duration.ofSeconds(300))
+            )
+            .withCreateContainerCmdModifier { cmd ->
+                cmd.hostConfig?.withMemory(4L * 1024 * 1024 * 1024) // 4 GB
+                cmd.hostConfig?.withMemorySwap(4L * 1024 * 1024 * 1024)
+            }
+    }
+
+    /**
+     * Set up adb port forwarding inside the Docker container.
+     *
+     * The MCP server runs inside the Android emulator, which has its own
+     * network stack. Testcontainers maps the Docker container's port to the
+     * test host, but we also need to forward from the container's localhost
+     * to the emulator's port. This is done via `adb forward` inside the
+     * container.
+     *
+     * Forward chain:
+     *   test host:randomPort <-> container:MCP_DEFAULT_PORT <-> emulator:MCP_DEFAULT_PORT
+     *
+     * @param container the running Docker container
+     */
+    fun setupPortForwarding(container: GenericContainer<*>) {
+        println("[E2E Setup] Setting up adb port forwarding (container:$MCP_DEFAULT_PORT -> emulator:$MCP_DEFAULT_PORT)...")
+
+        val result = execInContainer(
+            container,
+            "adb", "forward", "tcp:$MCP_DEFAULT_PORT", "tcp:$MCP_DEFAULT_PORT"
+        )
+        println("[E2E Setup] Port forwarding established: $result")
+    }
+
+    /**
+     * Wait for the Android emulator inside the container to fully boot.
+     *
+     * Polls `adb shell getprop sys.boot_completed` until it returns "1"
+     * or the timeout is exceeded.
+     *
+     * @param container the running Docker container
+     * @param timeoutMs maximum time to wait for boot (default 180 seconds)
+     * @throws IllegalStateException if emulator does not boot within timeout
+     */
+    fun waitForEmulatorBoot(
+        container: GenericContainer<*>,
+        timeoutMs: Long = DEFAULT_EMULATOR_BOOT_TIMEOUT_MS,
+    ) {
+        println("[E2E Setup] Waiting for emulator boot (timeout: ${timeoutMs}ms)...")
+
+        val startTime = System.currentTimeMillis()
+        while (System.currentTimeMillis() - startTime < timeoutMs) {
+            try {
+                val result = execInContainer(container, "adb", "shell", "getprop", "sys.boot_completed")
+                if (result.trim() == "1") {
+                    println("[E2E Setup] Emulator boot completed (${System.currentTimeMillis() - startTime}ms)")
+                    return
+                }
+            } catch (_: Exception) {
+                // adb may not be ready yet, continue polling
+            }
+            Thread.sleep(POLL_INTERVAL_MS)
+        }
+
+        throw IllegalStateException(
+            "Emulator did not boot within ${timeoutMs}ms. Check container logs for details."
+        )
+    }
+
+    /**
+     * Install the APK on the emulator inside the container.
+     *
+     * Copies the APK file into the container and installs it via adb.
+     *
+     * @param container the running Docker container
+     * @param apkPath path to the APK file on the host machine
+     * @throws IllegalStateException if APK installation fails
+     */
+    fun installApk(container: GenericContainer<*>, apkPath: String) {
+        val apkFile = File(apkPath)
+        require(apkFile.exists()) { "APK file not found: $apkPath" }
+
+        println("[E2E Setup] Installing APK: $apkPath")
+
+        // Copy APK into container
+        container.copyFileToContainer(
+            org.testcontainers.utility.MountableFile.forHostPath(apkPath),
+            "/tmp/app.apk"
+        )
+
+        // Install via adb
+        val result = execInContainer(container, "adb", "install", "-r", "/tmp/app.apk")
+        if (!result.contains("Success")) {
+            throw IllegalStateException("APK installation failed: $result")
+        }
+
+        println("[E2E Setup] APK installed successfully")
+    }
+
+    /**
+     * Enable the accessibility service via adb shell settings command.
+     *
+     * This sets the accessibility service as enabled in the secure settings,
+     * which is equivalent to the user toggling it on in Settings > Accessibility.
+     *
+     * @param container the running Docker container
+     */
+    fun enableAccessibilityService(container: GenericContainer<*>) {
+        println("[E2E Setup] Enabling accessibility service...")
+
+        val serviceComponent = "$APP_PACKAGE/$ACCESSIBILITY_SERVICE_CLASS"
+
+        execInContainer(
+            container,
+            "adb", "shell", "settings", "put", "secure",
+            "enabled_accessibility_services", serviceComponent
+        )
+
+        execInContainer(
+            container,
+            "adb", "shell", "settings", "put", "secure",
+            "accessibility_enabled", "1"
+        )
+
+        // Allow some time for the service to start
+        Thread.sleep(2_000)
+
+        println("[E2E Setup] Accessibility service enabled")
+    }
+
+    /**
+     * Configure the MCP server settings for E2E testing.
+     *
+     * Launches the app activity once to trigger initial DataStore creation,
+     * then uses adb to write to the app's SharedPreferences/DataStore files
+     * with the known bearer token, binding address 0.0.0.0, and the
+     * configured MCP port. After writing, force-stops and relaunches the app
+     * so the new settings take effect.
+     *
+     * The approach:
+     * 1. Launch the app briefly to create default DataStore files
+     * 2. Force-stop the app so files are flushed to disk
+     * 3. Use `adb shell` to write a pre-built DataStore preferences protobuf
+     *    file to the app's data directory at
+     *    /data/data/<package>/files/datastore/settings.preferences_pb
+     * 4. The protobuf file encodes the following key-value pairs:
+     *    - bearer_token = E2E_BEARER_TOKEN
+     *    - binding_address = "0.0.0.0"
+     *    - port = MCP_DEFAULT_PORT (8080)
+     *    - https_enabled = false
+     *
+     * If writing the DataStore protobuf is unreliable across versions, an
+     * alternative approach is used: launch the app with intent extras that
+     * the debug build handles for test configuration overrides:
+     *   adb shell am start -n <package>/<activity> \
+     *     --es "e2e_bearer_token" "<token>" \
+     *     --es "e2e_binding_address" "0.0.0.0" \
+     *     --ei "e2e_port" 8080
+     *
+     * @param container the running Docker container
+     */
+    fun configureServerSettings(container: GenericContainer<*>) {
+        println("[E2E Setup] Configuring MCP server settings for E2E testing...")
+
+        // Step 1: Launch the app briefly to trigger initial DataStore creation
+        execInContainer(
+            container,
+            "adb", "shell", "am", "start",
+            "-n", "$APP_PACKAGE/$MAIN_ACTIVITY_CLASS"
+        )
+        Thread.sleep(5_000)
+
+        // Step 2: Force-stop the app so DataStore files are flushed to disk
+        execInContainer(
+            container,
+            "adb", "shell", "am", "force-stop", APP_PACKAGE
+        )
+        Thread.sleep(1_000)
+
+        // Step 3: Write settings via adb shell commands
+        // Use the am broadcast approach with a debug-only BroadcastReceiver
+        // that accepts test configuration overrides. The receiver is registered
+        // only in debug builds (see app module debug source set).
+        // Action: com.danielealbano.androidremotecontrolmcp.debug.E2E_CONFIGURE
+        val configAction = "$APP_PACKAGE.E2E_CONFIGURE"
+        execInContainer(
+            container,
+            "adb", "shell", "am", "broadcast",
+            "-a", configAction,
+            "-n", "$APP_PACKAGE/.E2EConfigReceiver",
+            "--es", "bearer_token", E2E_BEARER_TOKEN,
+            "--es", "binding_address", "0.0.0.0",
+            "--ei", "port", MCP_DEFAULT_PORT.toString()
+        )
+        Thread.sleep(1_000)
+
+        println("[E2E Setup] Server settings configured via broadcast intent")
+    }
+
+    /**
+     * Start the MCP server by launching the MainActivity and then explicitly
+     * starting the McpServerService via adb shell am startservice.
+     *
+     * The activity launch triggers the UI and may auto-start the service,
+     * but we also send an explicit startservice command to ensure the server
+     * foreground service is running regardless of auto-start settings.
+     *
+     * @param container the running Docker container
+     */
+    fun startMcpServer(container: GenericContainer<*>) {
+        println("[E2E Setup] Starting MCP server...")
+
+        // Launch MainActivity to initialize the app
+        execInContainer(
+            container,
+            "adb", "shell", "am", "start",
+            "-n", "$APP_PACKAGE/$MAIN_ACTIVITY_CLASS"
+        )
+        Thread.sleep(3_000)
+
+        // Explicitly start the McpServerService foreground service
+        val serviceClass = "$APP_PACKAGE/${APP_PACKAGE.removeSuffix(".debug")}.services.mcp.McpServerService"
+        execInContainer(
+            container,
+            "adb", "shell", "am", "startservice",
+            "-n", serviceClass
+        )
+        Thread.sleep(2_000)
+
+        println("[E2E Setup] MCP server start commands sent (activity + service)")
+    }
+
+    /**
+     * Poll the /health endpoint until the MCP server is ready.
+     *
+     * @param baseUrl the base URL of the MCP server (e.g., "http://localhost:8080")
+     * @param bearerToken the bearer token (not used for health, but needed to construct McpClient)
+     * @param timeoutMs maximum time to wait for server ready (default 60 seconds)
+     * @throws IllegalStateException if server does not become ready within timeout
+     */
+    fun waitForServerReady(
+        baseUrl: String,
+        bearerToken: String = E2E_BEARER_TOKEN,
+        timeoutMs: Long = DEFAULT_SERVER_READY_TIMEOUT_MS,
+    ) {
+        println("[E2E Setup] Waiting for MCP server to be ready at $baseUrl (timeout: ${timeoutMs}ms)...")
+
+        val client = McpClient(baseUrl, bearerToken)
+        val startTime = System.currentTimeMillis()
+
+        while (System.currentTimeMillis() - startTime < timeoutMs) {
+            try {
+                val health = client.healthCheck()
+                val status = health["status"]?.toString()?.removeSurrounding("\"")
+                if (status == "healthy") {
+                    println("[E2E Setup] MCP server is ready (${System.currentTimeMillis() - startTime}ms)")
+                    return
+                }
+            } catch (_: Exception) {
+                // Server not ready yet, continue polling
+            }
+            Thread.sleep(HEALTH_POLL_INTERVAL_MS)
+        }
+
+        throw IllegalStateException(
+            "MCP server did not become ready within ${timeoutMs}ms at $baseUrl"
+        )
+    }
+
+    /**
+     * Get the mapped MCP server URL from a running container.
+     *
+     * @param container the running Docker container
+     * @return the base URL for the MCP server (e.g., "http://localhost:32768")
+     */
+    fun getMcpServerUrl(container: GenericContainer<*>): String {
+        val host = container.host
+        val port = container.getMappedPort(MCP_DEFAULT_PORT)
+        return "http://$host:$port"
+    }
+
+    /**
+     * Execute a command inside the Docker container and return stdout.
+     */
+    private fun execInContainer(container: GenericContainer<*>, vararg command: String): String {
+        val result = container.execInContainer(*command)
+        if (result.exitCode != 0 && result.stderr.isNotEmpty()) {
+            println("[E2E Setup] Command '${command.joinToString(" ")}' stderr: ${result.stderr}")
+        }
+        return result.stdout
+    }
+}
```

> **Implementation Note on DataStore Configuration**: The `configureServerSettings()` method uses a debug-only `BroadcastReceiver` (`E2EConfigReceiver`) to inject test settings via `adb shell am broadcast`. See Task 10.4.1b below for the receiver implementation and debug manifest entry.

---

### Task 10.4.1b: Create E2EConfigReceiver (Debug-only BroadcastReceiver)

**Description**: Create the `E2EConfigReceiver` class in the app module's debug source set and register it in a debug-only `AndroidManifest.xml` overlay. This receiver is the prerequisite for `configureServerSettings()` to work — it accepts a broadcast intent with test configuration extras (bearer_token, binding_address, port) and writes them into `SettingsRepository`/DataStore.

**Acceptance Criteria**:
- [ ] `E2EConfigReceiver` class exists at `app/src/debug/kotlin/com/danielealbano/androidremotecontrolmcp/debug/E2EConfigReceiver.kt`
- [ ] Receiver handles action `com.danielealbano.androidremotecontrolmcp.debug.E2E_CONFIGURE`
- [ ] Receiver extracts `bearer_token` (String), `binding_address` (String), and `port` (Int) from intent extras
- [ ] Receiver writes extracted values into `SettingsRepository` via DataStore
- [ ] Receiver is annotated with `@AndroidEntryPoint` for Hilt injection of `SettingsRepository`
- [ ] Debug-only `AndroidManifest.xml` overlay at `app/src/debug/AndroidManifest.xml` registers the receiver with `exported="false"`
- [ ] Receiver only exists in debug builds (not in release)
- [ ] Receiver logs configuration changes via `Logger`

**Tests**: Implicitly tested by E2E tests. No separate unit tests needed (debug-only code).

#### Action 10.4.1b.1: Create debug source set directory structure

**What**: Create the debug source set directories for the E2EConfigReceiver.

**Command to run**:
```bash
mkdir -p app/src/debug/kotlin/com/danielealbano/androidremotecontrolmcp/debug
```

#### Action 10.4.1b.2: Create `E2EConfigReceiver.kt`

**What**: Create the debug-only BroadcastReceiver that accepts test configuration via adb broadcast.

**Context**: This receiver is ONLY compiled into debug builds. It allows E2E tests to inject server settings (bearer token, binding address, port) into the app's DataStore without manipulating protobuf files directly. The receiver uses Hilt to inject `SettingsRepository` and writes the settings using the same validation and persistence logic as the UI. The receiver runs in the app process, so coroutine access to DataStore is straightforward.

**File**: `app/src/debug/kotlin/com/danielealbano/androidremotecontrolmcp/debug/E2EConfigReceiver.kt`

```diff
--- /dev/null
+++ b/app/src/debug/kotlin/com/danielealbano/androidremotecontrolmcp/debug/E2EConfigReceiver.kt
@@ -0,0 +1,73 @@
+package com.danielealbano.androidremotecontrolmcp.debug
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.util.Log
+import com.danielealbano.androidremotecontrolmcp.data.model.BindingAddress
+import com.danielealbano.androidremotecontrolmcp.data.repository.SettingsRepository
+import dagger.hilt.android.AndroidEntryPoint
+import javax.inject.Inject
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.SupervisorJob
+import kotlinx.coroutines.launch
+
+/**
+ * Debug-only [BroadcastReceiver] that accepts test configuration overrides
+ * via `adb shell am broadcast`.
+ *
+ * This receiver is ONLY included in debug builds. It allows E2E tests to
+ * inject server settings (bearer token, binding address, port) into the
+ * app's DataStore without manipulating protobuf files directly.
+ *
+ * **Usage** (from E2E test via adb):
+ * ```
+ * adb shell am broadcast \
+ *   -a com.danielealbano.androidremotecontrolmcp.debug.E2E_CONFIGURE \
+ *   -n com.danielealbano.androidremotecontrolmcp.debug/.E2EConfigReceiver \
+ *   --es bearer_token "test-token-uuid" \
+ *   --es binding_address "0.0.0.0" \
+ *   --ei port 8080
+ * ```
+ */
+@AndroidEntryPoint
+class E2EConfigReceiver : BroadcastReceiver() {
+
+    @Inject
+    lateinit var settingsRepository: SettingsRepository
+
+    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
+
+    override fun onReceive(context: Context, intent: Intent) {
+        if (intent.action != ACTION_E2E_CONFIGURE) {
+            Log.w(TAG, "Ignoring unexpected action: ${intent.action}")
+            return
+        }
+
+        Log.i(TAG, "Received E2E configuration broadcast")
+
+        val bearerToken = intent.getStringExtra(EXTRA_BEARER_TOKEN)
+        val bindingAddress = intent.getStringExtra(EXTRA_BINDING_ADDRESS)
+        val port = intent.getIntExtra(EXTRA_PORT, -1)
+
+        scope.launch {
+            if (!bearerToken.isNullOrEmpty()) {
+                settingsRepository.updateBearerToken(bearerToken)
+                Log.i(TAG, "Bearer token updated (length=${bearerToken.length})")
+            }
+            if (!bindingAddress.isNullOrEmpty()) {
+                val address = if (bindingAddress == "0.0.0.0") {
+                    BindingAddress.ALL_INTERFACES
+                } else {
+                    BindingAddress.LOCALHOST
+                }
+                settingsRepository.updateBindingAddress(address)
+                Log.i(TAG, "Binding address updated to $address")
+            }
+            if (port in 1..65535) {
+                settingsRepository.updatePort(port)
+                Log.i(TAG, "Port updated to $port")
+            }
+            Log.i(TAG, "E2E configuration applied successfully")
+        }
+    }
+
+    companion object {
+        private const val TAG = "E2E:ConfigReceiver"
+        const val ACTION_E2E_CONFIGURE = "com.danielealbano.androidremotecontrolmcp.debug.E2E_CONFIGURE"
+        private const val EXTRA_BEARER_TOKEN = "bearer_token"
+        private const val EXTRA_BINDING_ADDRESS = "binding_address"
+        private const val EXTRA_PORT = "port"
+    }
+}
```

#### Action 10.4.1b.3: Create debug-only `AndroidManifest.xml` overlay

**What**: Create the debug-only manifest overlay that registers the `E2EConfigReceiver`.

**Context**: Android's build system merges source set manifests. The debug manifest overlay adds the `E2EConfigReceiver` registration that only exists in debug builds. The receiver is NOT exported (`android:exported="false"`) but uses a custom action filter so it can be invoked via `adb shell am broadcast -a <action>`. Since it targets the component explicitly (`-n <package>/<class>`), `exported="false"` is sufficient for `adb` invocations (adb runs as shell user with access to unexported components on debuggable apps).

**File**: `app/src/debug/AndroidManifest.xml`

```diff
--- /dev/null
+++ b/app/src/debug/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <!--
+      Debug-only manifest overlay.
+      Registers E2EConfigReceiver for test configuration injection.
+      This receiver is NOT included in release builds.
+    -->
+    <application>
+        <receiver
+            android:name=".debug.E2EConfigReceiver"
+            android:exported="false">
+        </receiver>
+    </application>
+
+</manifest>
```

> **Implementation Note -- Component name resolution**: In the Android manifest, `android:name` resolves relative to the `namespace` (base package), NOT the `applicationId`. Since the class is at `com.danielealbano.androidremotecontrolmcp.debug.E2EConfigReceiver`, the manifest must use `.debug.E2EConfigReceiver`. In contrast, the `adb` command component uses the applicationId as the first part, so `"$APP_PACKAGE/.E2EConfigReceiver"` resolves correctly.

---

### Task 10.4.2: Create Shared Container Singleton for E2E Tests

**Description**: Create `SharedAndroidContainer.kt` — a singleton object that manages a single Docker Android container shared across ALL E2E test classes. This avoids the 6-12 minute penalty of booting a separate container per test class.

**Acceptance Criteria**:
- [ ] `SharedAndroidContainer` is an `object` with a lazily initialized container
- [ ] Container is started once on first access and reused across all test classes
- [ ] APK installation, accessibility enablement, server config, port forwarding, server start, and health check polling are done once during initialization
- [ ] A JVM shutdown hook stops the container when all tests complete
- [ ] All E2E test classes use this shared container instead of creating their own

**Tests**: Implicitly tested by E2E tests. No separate unit tests needed.

#### Action 10.4.2.1: Create `SharedAndroidContainer.kt`

**What**: Create a singleton that manages the shared Docker Android container lifecycle.

**Context**: Without sharing, each of the 3 E2E test classes (Calculator, Screenshot, ErrorHandling) would boot its own Docker container, adding 2-4 minutes per class. By using a singleton with lazy initialization, the container boots once on first access and is reused. A JVM shutdown hook ensures cleanup. This follows the Testcontainers singleton pattern recommended for expensive containers.

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/SharedAndroidContainer.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/SharedAndroidContainer.kt
@@ -0,0 +1,80 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import org.testcontainers.containers.GenericContainer
+
+/**
+ * Singleton that manages a single shared Docker Android container
+ * for all E2E test classes.
+ *
+ * The container is lazily initialized on first access and reused
+ * across all test classes. A JVM shutdown hook stops the container
+ * when the test JVM exits.
+ *
+ * This avoids booting a separate Android emulator container per
+ * test class (~2-4 minutes each), reducing total E2E runtime from
+ * ~10-15 minutes to ~5-7 minutes.
+ */
+object SharedAndroidContainer {
+
+    /**
+     * Path to the debug APK. Relative to the project root.
+     * Must be built before running E2E tests: `./gradlew assembleDebug`
+     */
+    private const val APK_PATH = "app/build/outputs/apk/debug/app-debug.apk"
+
+    /**
+     * The shared Docker Android container instance.
+     * Lazily initialized on first access.
+     */
+    val container: GenericContainer<*> by lazy {
+        val c = AndroidContainerSetup.createContainer()
+        c.start()
+
+        // Wait for emulator boot
+        AndroidContainerSetup.waitForEmulatorBoot(c)
+
+        // Set up port forwarding from container to emulator
+        AndroidContainerSetup.setupPortForwarding(c)
+
+        // Install APK
+        AndroidContainerSetup.installApk(c, APK_PATH)
+
+        // Enable accessibility service
+        AndroidContainerSetup.enableAccessibilityService(c)
+
+        // Configure server settings (binding 0.0.0.0, known bearer token)
+        AndroidContainerSetup.configureServerSettings(c)
+
+        // Start MCP server (activity + explicit service start)
+        AndroidContainerSetup.startMcpServer(c)
+
+        // Wait for server to be ready (polls GET /health until 200 or timeout)
+        val url = AndroidContainerSetup.getMcpServerUrl(c)
+        AndroidContainerSetup.waitForServerReady(url)
+
+        println("[SharedAndroidContainer] Container fully initialized and MCP server ready at $url")
+
+        c
+    }
+
+    /**
+     * The base URL of the MCP server, derived from the shared container.
+     */
+    val mcpServerUrl: String by lazy {
+        AndroidContainerSetup.getMcpServerUrl(container)
+    }
+
+    /**
+     * A pre-configured McpClient using the shared container's URL and E2E bearer token.
+     */
+    val mcpClient: McpClient by lazy {
+        val client = McpClient(mcpServerUrl, AndroidContainerSetup.E2E_BEARER_TOKEN)
+        client.initialize()
+        client
+    }
+
+    init {
+        // Register JVM shutdown hook to stop the container when all tests complete
+        Runtime.getRuntime().addShutdownHook(Thread {
+            println("[SharedAndroidContainer] Stopping shared container...")
+            if (container.isRunning) {
+                container.stop()
+            }
+            println("[SharedAndroidContainer] Shared container stopped")
+        })
+    }
+}
```

---

### Task 10.5: Create Calculator E2E Test

**Description**: Create `E2ECalculatorTest.kt` — the main E2E test that verifies full MCP stack integration by performing a 7 + 3 = 10 calculation on the Android Calculator app.

**Acceptance Criteria**:
- [ ] Test class uses `@TestInstance(Lifecycle.PER_CLASS)` and `SharedAndroidContainer` singleton
- [ ] Container is shared via `SharedAndroidContainer` (no per-class container lifecycle)
- [ ] `McpClient` is obtained from `SharedAndroidContainer.mcpClient`
- [ ] Test presses home first to ensure clean state
- [ ] Test launches Calculator app via adb or MCP system actions
- [ ] Test verifies Calculator is visible in accessibility tree
- [ ] Test finds and clicks "7" button via MCP tools
- [ ] Test finds and clicks "+" button via MCP tools
- [ ] Test finds and clicks "3" button via MCP tools
- [ ] Test finds and clicks "=" button via MCP tools
- [ ] Test waits for UI idle after calculation
- [ ] Test verifies "10" appears in the accessibility tree result
- [ ] Test captures a screenshot and verifies non-empty data
- [ ] Test uses flexible element matching (contains, not exact) for Calculator button text
- [ ] Test has descriptive assertion messages for debugging failures

**Tests**: This IS the E2E test. Run via `make test-e2e` or `./gradlew :e2e-tests:test`.

#### Action 10.5.1: Create `E2ECalculatorTest.kt`

**What**: Create the Calculator E2E test.

**Context**: The AOSP Calculator app is pre-installed on the Android emulator. Button text varies by version but typically uses digits ("7", "3") and operators ("+", "="). The test uses `find_elements` with `by=text` and `exact_match=false` (contains matching) to be resilient across versions. For the "+" button, it also tries `content_desc` as some Calculator implementations use content descriptions like "plus" instead of showing "+" as text. The result display typically shows the number in a `TextView` — we search for "10" in the tree. If `find_elements` returns no results for text matching, the test falls back to searching by `content_desc`.

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2ECalculatorTest.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2ECalculatorTest.kt
@@ -0,0 +1,233 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import kotlinx.serialization.json.JsonPrimitive
+import kotlinx.serialization.json.contentOrNull
+import kotlinx.serialization.json.jsonArray
+import kotlinx.serialization.json.jsonObject
+import kotlinx.serialization.json.jsonPrimitive
+import org.junit.jupiter.api.Assertions.assertFalse
+import org.junit.jupiter.api.Assertions.assertNotNull
+import org.junit.jupiter.api.Assertions.assertTrue
+import org.junit.jupiter.api.MethodOrderer
+import org.junit.jupiter.api.Order
+import org.junit.jupiter.api.Test
+import org.junit.jupiter.api.TestInstance
+import org.junit.jupiter.api.TestMethodOrder
+
+/**
+ * E2E test: Calculator App (7 + 3 = 10)
+ *
+ * This test verifies the entire MCP stack by:
+ * 1. Using the shared Docker Android emulator (via [SharedAndroidContainer])
+ * 2. Using MCP tools to interact with the Calculator app
+ * 3. Verifying the calculation result via accessibility tree
+ * 4. Capturing a screenshot and verifying it contains data
+ *
+ * Uses [SharedAndroidContainer] singleton to share the Docker container
+ * across all E2E test classes, avoiding ~2-4 minute container boot per class.
+ *
+ * Requires Docker to be available on the host machine.
+ */
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
+class E2ECalculatorTest {
+
+    private val container = SharedAndroidContainer.container
+    private val mcpClient = SharedAndroidContainer.mcpClient
+    private val baseUrl = SharedAndroidContainer.mcpServerUrl
+
+    companion object {
+        /**
+         * Maximum time to wait for element search before giving up.
+         */
+        private const val ELEMENT_WAIT_TIMEOUT_MS = 10_000L
+    }
+
+    @Test
+    @Order(1)
+    fun `MCP server health check returns healthy`() {
+        val health = mcpClient.healthCheck()
+        val status = health["status"]?.jsonPrimitive?.contentOrNull
+        assertTrue(status == "healthy", "Health check should return 'healthy', got: $status")
+    }
+
+    @Test
+    @Order(2)
+    fun `MCP server lists all available tools`() {
+        val tools = mcpClient.listTools()
+        assertTrue(tools.size >= 29, "Expected at least 29 tools, got: ${tools.size}")
+    }
+
+    @Test
+    @Order(3)
+    fun `calculate 7 plus 3 equals 10`() {
+        // Step 1: Press home to ensure clean state
+        mcpClient.callTool("press_home")
+        Thread.sleep(1_000)
+
+        // Step 2: Launch Calculator app via adb (more reliable than tapping launcher)
+        container.execInContainer(
+            "adb", "shell", "am", "start",
+            "-n", "com.android.calculator2/.Calculator"
+        )
+        Thread.sleep(2_000)
+
+        // Step 3: Verify Calculator is visible in accessibility tree
+        val tree = mcpClient.callTool("get_accessibility_tree")
+        val treeStr = tree.toString()
+        assertTrue(
+            treeStr.contains("alculator", ignoreCase = true),
+            "Accessibility tree should contain Calculator app. Tree excerpt: ${treeStr.take(500)}"
+        )
+
+        // Step 4: Find and click "7" button
+        val button7 = findElementWithRetry("text", "7")
+        assertNotNull(button7, "Could not find '7' button in Calculator")
+        mcpClient.callTool("click_element", mapOf("element_id" to button7!!))
+        Thread.sleep(500)
+
+        // Step 5: Find and click "+" button
+        val buttonPlus = findElementWithRetry("text", "+")
+            ?: findElementWithRetry("content_desc", "plus")
+        assertNotNull(buttonPlus, "Could not find '+' button in Calculator")
+        mcpClient.callTool("click_element", mapOf("element_id" to buttonPlus!!))
+        Thread.sleep(500)
+
+        // Step 6: Find and click "3" button
+        val button3 = findElementWithRetry("text", "3")
+        assertNotNull(button3, "Could not find '3' button in Calculator")
+        mcpClient.callTool("click_element", mapOf("element_id" to button3!!))
+        Thread.sleep(500)
+
+        // Step 7: Find and click "=" button
+        val buttonEquals = findElementWithRetry("text", "=")
+            ?: findElementWithRetry("content_desc", "equals")
+        assertNotNull(buttonEquals, "Could not find '=' button in Calculator")
+        mcpClient.callTool("click_element", mapOf("element_id" to buttonEquals!!))
+        Thread.sleep(1_000)
+
+        // Step 8: Wait for UI to settle
+        mcpClient.callTool("wait_for_idle", mapOf("timeout" to 3000))
+
+        // Step 9: Verify result "10" in accessibility tree
+        val resultTree = mcpClient.callTool("get_accessibility_tree")
+        val resultTreeStr = resultTree.toString()
+        assertTrue(
+            resultTreeStr.contains("10"),
+            "Result '10' should appear in accessibility tree after 7+3=. Tree excerpt: ${resultTreeStr.take(500)}"
+        )
+    }
+
+    @Test
+    @Order(4)
+    fun `capture screenshot returns valid image data`() {
+        val screenshot = mcpClient.callTool("capture_screenshot", mapOf("quality" to 80))
+
+        val format = screenshot["format"]?.jsonPrimitive?.contentOrNull
+        assertTrue(format == "jpeg", "Screenshot format should be 'jpeg', got: $format")
+
+        val data = screenshot["data"]?.jsonPrimitive?.contentOrNull
+        assertNotNull(data, "Screenshot data should not be null")
+        assertFalse(data!!.isEmpty(), "Screenshot data should not be empty")
+        assertTrue(data.length > 100, "Screenshot data should be substantial (got ${data.length} chars)")
+
+        val width = screenshot["width"]?.jsonPrimitive?.contentOrNull?.toIntOrNull()
+        val height = screenshot["height"]?.jsonPrimitive?.contentOrNull?.toIntOrNull()
+        assertNotNull(width, "Screenshot width should be present")
+        assertNotNull(height, "Screenshot height should be present")
+        assertTrue(width!! > 0, "Screenshot width should be > 0, got: $width")
+        assertTrue(height!! > 0, "Screenshot height should be > 0, got: $height")
+    }
+
+    /**
+     * Find an element by criteria, retrying up to ELEMENT_WAIT_TIMEOUT_MS.
+     * Returns the element_id of the first match, or null if not found.
+     */
+    private fun findElementWithRetry(by: String, value: String): String? {
+        val startTime = System.currentTimeMillis()
+
+        while (System.currentTimeMillis() - startTime < ELEMENT_WAIT_TIMEOUT_MS) {
+            try {
+                val result = mcpClient.callTool(
+                    "find_elements",
+                    mapOf("by" to by, "value" to value, "exact_match" to true)
+                )
+                val elements = result["elements"]?.jsonArray
+                if (elements != null && elements.isNotEmpty()) {
+                    return elements[0].jsonObject["id"]?.jsonPrimitive?.contentOrNull
+                }
+            } catch (_: Exception) {
+                // Element not found yet, retry
+            }
+            Thread.sleep(500)
+        }
+
+        return null
+    }
+}
```

> **CRITICAL -- Wrong response structure in E2E tests**: The tests access `screenshot["format"]`, `screenshot["data"]`, `screenshot["width"]`, `screenshot["height"]` at the top level. However, `McpContentBuilder.imageContent()` wraps the response in a `content` array, and the field is `mimeType` not `format`. At implementation time, update assertions to navigate the content structure correctly.

> **Implementation Note on Calculator Package**: The Calculator app package name varies by Android distribution. On AOSP emulators it is typically `com.android.calculator2` with activity `.Calculator`. On some Google-branded emulators it may be `com.google.android.calculator`. At implementation time, verify the correct package by running `adb shell pm list packages | grep calc` inside the container. If the package differs, adjust the `am start` command. Consider adding a fallback: try `com.android.calculator2/.Calculator` first, and if it fails, try `com.google.android.calculator/com.android.calculator2.Calculator`.

> **Implementation Note on "10" Verification**: The Calculator result display may show "10" as text or may display it as part of a larger expression (e.g., "7+3=10"). The test uses `contains("10")` on the full tree string, which is intentionally broad. At implementation time, consider tightening this by searching specifically for a result display element. However, the broad check is sufficient for verifying the calculation succeeded.

---

## User Story 2: Additional E2E Test Scenarios

**As a** developer or maintainer of the Android Remote Control MCP project
**I want** E2E tests that verify screenshot functionality and error handling beyond the Calculator test
**So that** I can ensure the MCP server handles edge cases and error conditions correctly in a real Android environment.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] `E2EScreenshotTest` captures screenshots with different quality settings and verifies format/data
- [ ] `E2EScreenshotTest` verifies higher quality produces larger data
- [ ] `E2EScreenshotTest` uses `SharedAndroidContainer` (no per-class container)
- [ ] `E2EErrorHandlingTest` verifies missing/empty bearer token returns HTTP 401
- [ ] `E2EErrorHandlingTest` verifies invalid/wrong bearer token returns HTTP 401
- [ ] `E2EErrorHandlingTest` verifies correct bearer token succeeds (200)
- [ ] `E2EErrorHandlingTest` verifies unknown tool name returns JSON-RPC error -32601
- [ ] `E2EErrorHandlingTest` verifies invalid params returns JSON-RPC error -32602
- [ ] `E2EErrorHandlingTest` verifies click on non-existent element returns JSON-RPC error -32002
- [ ] `E2EErrorHandlingTest` verifies health endpoint accessible without auth
- [ ] `E2EErrorHandlingTest` uses `SharedAndroidContainer` (no per-class container)
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings
- [ ] `make test-e2e` passes (if Docker is available)

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 3 | `test: add screenshot and error handling E2E tests` | `E2EScreenshotTest.kt`, `E2EErrorHandlingTest.kt` |

---

### Task 10.6: Create Screenshot E2E Test

**Description**: Create `E2EScreenshotTest.kt` — E2E test that verifies screenshot capture with different quality settings.

**Acceptance Criteria**:
- [ ] Test captures screenshot with quality=80 and verifies format, data, width, height
- [ ] Test captures screenshot with quality=10 (low) and quality=95 (high)
- [ ] Test verifies higher quality produces larger base64 data than lower quality
- [ ] Test shares Docker container with other E2E tests (same container setup pattern)

**Tests**: This IS the E2E test. Run via `make test-e2e`.

#### Action 10.6.1: Create `E2EScreenshotTest.kt`

**What**: Create the screenshot E2E test.

**Context**: This test verifies that the `capture_screenshot` MCP tool works correctly in a real Android environment with an actual MediaProjection session. It tests quality parameter handling by comparing output sizes at different quality levels.

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2EScreenshotTest.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2EScreenshotTest.kt
@@ -0,0 +1,131 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import kotlinx.serialization.json.contentOrNull
+import kotlinx.serialization.json.jsonPrimitive
+import org.junit.jupiter.api.Assertions.assertFalse
+import org.junit.jupiter.api.Assertions.assertNotNull
+import org.junit.jupiter.api.Assertions.assertTrue
+import org.junit.jupiter.api.MethodOrderer
+import org.junit.jupiter.api.Order
+import org.junit.jupiter.api.Test
+import org.junit.jupiter.api.TestInstance
+import org.junit.jupiter.api.TestMethodOrder
+
+/**
+ * E2E test: Screenshot capture verification.
+ *
+ * Verifies that the capture_screenshot MCP tool returns valid JPEG data
+ * with correct format, dimensions, and quality-dependent sizes.
+ *
+ * Uses [SharedAndroidContainer] singleton to share the Docker container
+ * across all E2E test classes, avoiding ~2-4 minute container boot per class.
+ */
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
+class E2EScreenshotTest {
+
+    private val mcpClient = SharedAndroidContainer.mcpClient
+
+    @Test
+    @Order(1)
+    fun `capture screenshot of home screen returns valid JPEG data`() {
+        // Navigate to home screen first
+        mcpClient.callTool("press_home")
+        Thread.sleep(1_000)
+
+        val screenshot = mcpClient.callTool("capture_screenshot", mapOf("quality" to 80))
+
+        val format = screenshot["format"]?.jsonPrimitive?.contentOrNull
+        assertTrue(format == "jpeg", "Format should be 'jpeg', got: $format")
+
+        val data = screenshot["data"]?.jsonPrimitive?.contentOrNull
+        assertNotNull(data, "Screenshot data should not be null")
+        assertFalse(data!!.isEmpty(), "Screenshot data should not be empty")
+
+        val width = screenshot["width"]?.jsonPrimitive?.contentOrNull?.toIntOrNull()
+        val height = screenshot["height"]?.jsonPrimitive?.contentOrNull?.toIntOrNull()
+        assertNotNull(width, "Width should be present")
+        assertNotNull(height, "Height should be present")
+        assertTrue(width!! > 0, "Width should be > 0")
+        assertTrue(height!! > 0, "Height should be > 0")
+
+        println("Screenshot: ${width}x${height}, format=$format, data size=${data.length} chars")
+    }
+
+    @Test
+    @Order(2)
+    fun `higher quality produces larger screenshot data`() {
+        // Capture at low quality
+        val lowQuality = mcpClient.callTool("capture_screenshot", mapOf("quality" to 10))
+        val lowData = lowQuality["data"]?.jsonPrimitive?.contentOrNull
+        assertNotNull(lowData, "Low quality screenshot data should not be null")
+
+        // Small delay between captures
+        Thread.sleep(500)
+
+        // Capture at high quality
+        val highQuality = mcpClient.callTool("capture_screenshot", mapOf("quality" to 95))
+        val highData = highQuality["data"]?.jsonPrimitive?.contentOrNull
+        assertNotNull(highData, "High quality screenshot data should not be null")
+
+        println("Low quality (10) data size: ${lowData!!.length} chars")
+        println("High quality (95) data size: ${highData!!.length} chars")
+
+        assertTrue(
+            highData.length > lowData.length,
+            "High quality screenshot (${highData.length} chars) should be larger than " +
+                "low quality (${lowData.length} chars)"
+        )
+    }
+}
```

> **CRITICAL -- Wrong response structure in E2E tests**: The tests access `screenshot["format"]`, `screenshot["data"]`, `screenshot["width"]`, `screenshot["height"]` at the top level. However, `McpContentBuilder.imageContent()` wraps the response in a `content` array, and the field is `mimeType` not `format`. At implementation time, update assertions to navigate the content structure correctly.

---

### Task 10.7: Create Error Handling E2E Test

**Description**: Create `E2EErrorHandlingTest.kt` — E2E test that verifies the MCP server correctly handles authentication errors, unknown tools, invalid parameters, and element-not-found errors.

**Acceptance Criteria**:
- [ ] Missing/empty bearer token returns HTTP 401
- [ ] Invalid/wrong bearer token returns HTTP 401
- [ ] Empty Authorization header (empty string token) returns HTTP 401
- [ ] Correct bearer token returns successful response (200)
- [ ] Unknown tool name returns JSON-RPC error -32601
- [ ] Invalid tool params (missing required field) returns JSON-RPC error -32602
- [ ] Click on non-existent element_id returns JSON-RPC error -32002
- [ ] Health endpoint is accessible without authentication
- [ ] All error assertions include descriptive messages
- [ ] Uses `SharedAndroidContainer` (no per-class container lifecycle)

**Tests**: This IS the E2E test. Run via `make test-e2e`.

#### Action 10.7.1: Create `E2EErrorHandlingTest.kt`

**What**: Create the error handling E2E test.

**Context**: This test verifies that the MCP server returns correct error codes and HTTP status codes for various error conditions. It creates two `McpClient` instances: one with the correct bearer token (for tool-level error testing) and one with incorrect/missing tokens (for auth error testing).

**File**: `e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2EErrorHandlingTest.kt`

```diff
--- /dev/null
+++ b/e2e-tests/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/e2e/E2EErrorHandlingTest.kt
@@ -0,0 +1,160 @@
+package com.danielealbano.androidremotecontrolmcp.e2e
+
+import org.junit.jupiter.api.Assertions.assertEquals
+import org.junit.jupiter.api.Assertions.assertTrue
+import org.junit.jupiter.api.Assertions.fail
+import org.junit.jupiter.api.Test
+import org.junit.jupiter.api.TestInstance
+
+/**
+ * E2E test: Error handling and authentication verification.
+ *
+ * Verifies that the MCP server correctly handles:
+ * - Authentication errors (missing token, empty header, invalid/wrong token)
+ * - Correct token (should succeed)
+ * - Unknown tool names
+ * - Invalid tool parameters
+ * - Element not found errors
+ *
+ * Uses [SharedAndroidContainer] singleton to share the Docker container
+ * across all E2E test classes, avoiding ~2-4 minute container boot per class.
+ */
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+class E2EErrorHandlingTest {
+
+    private val mcpClient = SharedAndroidContainer.mcpClient
+    private val baseUrl = SharedAndroidContainer.mcpServerUrl
+
+    @Test
+    fun `missing bearer token returns 401 Unauthorized`() {
+        // Create client with empty token — sends "Authorization: Bearer " with empty value
+        val noAuthClient = McpClient(baseUrl, "")
+
+        try {
+            noAuthClient.callTool("press_home")
+            fail("Expected McpClientException with status 401")
+        } catch (e: McpClientException) {
+            assertEquals(
+                401,
+                e.statusCode,
+                "Missing/empty bearer token should return 401, got: ${e.statusCode}"
+            )
+        }
+    }
+
+    @Test
+    fun `invalid bearer token returns 401 Unauthorized`() {
+        val badAuthClient = McpClient(baseUrl, "invalid-token-that-does-not-match")
+
+        try {
+            badAuthClient.callTool("press_home")
+            fail("Expected McpClientException with status 401")
+        } catch (e: McpClientException) {
+            assertEquals(
+                401,
+                e.statusCode,
+                "Invalid bearer token should return 401, got: ${e.statusCode}"
+            )
+        }
+    }
+
+    @Test
+    fun `correct bearer token returns successful response`() {
+        // The shared mcpClient already has the correct token; verify a simple tool call succeeds
+        val result = mcpClient.callTool("press_home")
+        // If we get here without exception, the auth succeeded
+        assertTrue(true, "Correct bearer token should allow tool call to succeed")
+    }
+
+    @Test
+    fun `unknown tool name returns JSON-RPC error -32601`() {
+        try {
+            mcpClient.callTool("nonexistent_tool_name")
+            fail("Expected McpRpcException with code -32601")
+        } catch (e: McpRpcException) {
+            assertEquals(
+                -32601,
+                e.code,
+                "Unknown tool should return error code -32601, got: ${e.code}"
+            )
+        }
+    }
+
+    @Test
+    fun `invalid params returns JSON-RPC error -32602`() {
+        // Call tap without required x,y coordinates
+        try {
+            mcpClient.callTool("tap", emptyMap())
+            fail("Expected McpRpcException with code -32602")
+        } catch (e: McpRpcException) {
+            assertEquals(
+                -32602,
+                e.code,
+                "Missing required params should return error code -32602, got: ${e.code}"
+            )
+        }
+    }
+
+    @Test
+    fun `click on non-existent element returns JSON-RPC error -32002`() {
+        try {
+            mcpClient.callTool(
+                "click_element",
+                mapOf("element_id" to "nonexistent_element_id_12345")
+            )
+            fail("Expected McpRpcException with code -32002")
+        } catch (e: McpRpcException) {
+            assertEquals(
+                -32002,
+                e.code,
+                "Non-existent element should return error code -32002, got: ${e.code}"
+            )
+        }
+    }
+
+    @Test
+    fun `health endpoint is accessible without authentication`() {
+        // Health check should work even with a bad token client
+        val noAuthClient = McpClient(baseUrl, "wrong-token")
+        val health = noAuthClient.healthCheck()
+
+        val status = health["status"]?.toString()?.removeSurrounding("\"")
+        assertTrue(
+            status == "healthy",
+            "Health endpoint should be accessible without auth and return 'healthy', got: $status"
+        )
+    }
+}
```

---

## User Story 3: Jacoco Coverage Integration

**As a** developer or maintainer of the Android Remote Control MCP project
**I want** automated code coverage reports with a minimum 80% threshold for unit tests
**So that** I can monitor test coverage and prevent coverage regressions.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] `app/build.gradle.kts` includes Jacoco plugin
- [ ] `jacocoTestReport` task generates HTML and XML reports
- [ ] `jacocoTestCoverageVerification` task enforces 80% minimum coverage
- [ ] HTML report output at `app/build/reports/jacoco/jacocoTestReport/html/index.html`
- [ ] XML report output at `app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml`
- [ ] `make coverage` works and generates the report
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 4 | `chore: add Jacoco coverage integration` | Updated `app/build.gradle.kts` |

---

### Task 10.8: Add Jacoco Plugin and Configuration to App Build Script

**Description**: Add the Jacoco plugin to `app/build.gradle.kts` with report generation and coverage verification tasks.

**Acceptance Criteria**:
- [ ] `jacoco` plugin applied
- [ ] `jacoco` tool version set to latest stable (0.8.12, verify at implementation time)
- [ ] `jacocoTestReport` task configured with HTML and XML outputs
- [ ] `jacocoTestReport` depends on `testDebugUnitTest`
- [ ] `jacocoTestCoverageVerification` task configured with 80% minimum line coverage
- [ ] Reports use correct source directories and class directories (excluding generated code like Hilt, R, BuildConfig)
- [ ] Coverage verification excludes generated classes (Hilt modules, Dagger components, BuildConfig, R)

**Tests**: `make coverage` generates the report successfully.

#### Action 10.8.1: Update `app/build.gradle.kts` with Jacoco configuration

**What**: Add Jacoco plugin and configure report and verification tasks.

**Context**: Jacoco measures code coverage for unit tests. The configuration must exclude Android-generated classes (R, BuildConfig) and Hilt/Dagger-generated classes from coverage calculation. The `jacocoTestReport` task depends on `testDebugUnitTest` to ensure tests run before report generation. The report generates both HTML (for human reading) and XML (for CI tools like Codecov or SonarQube).

**File**: `app/build.gradle.kts`

```diff
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ At the top, after the existing plugins block
 plugins {
     alias(libs.plugins.android.application)
     alias(libs.plugins.kotlin.android)
     alias(libs.plugins.kotlin.compose)
     alias(libs.plugins.hilt)
     alias(libs.plugins.kotlin.serialization)
     alias(libs.plugins.ksp)
     alias(libs.plugins.ktlint)
     alias(libs.plugins.detekt)
+    jacoco
 }

@@ At the bottom of the file, after the tasks.withType<Test> block
+jacoco {
+    toolVersion = "0.8.12" // verify latest at implementation time
+}
+
+val jacocoExcludes = listOf(
+    // Android generated
+    "**/R.class",
+    "**/R$*.class",
+    "**/BuildConfig.*",
+    "**/Manifest*.*",
+    // Hilt / Dagger generated
+    "**/*_HiltModules*",
+    "**/*_Factory*",
+    "**/*_MembersInjector*",
+    "**/Hilt_*",
+    "**/dagger/**",
+    "**/*Module_*",
+    "**/*_Impl*",
+    // Compose generated
+    "**/*ComposableSingletons*",
+)
+
+tasks.register<JacocoReport>("jacocoTestReport") {
+    dependsOn("testDebugUnitTest")
+
+    reports {
+        html.required.set(true)
+        html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco/jacocoTestReport/html"))
+        xml.required.set(true)
+        xml.outputLocation.set(layout.buildDirectory.file("reports/jacoco/jacocoTestReport/jacocoTestReport.xml"))
+        csv.required.set(false)
+    }
+
+    val debugTree = fileTree("${layout.buildDirectory.get()}/tmp/kotlin-classes/debug") {
+        exclude(jacocoExcludes)
+    }
+
+    classDirectories.setFrom(debugTree)
+    sourceDirectories.setFrom(files("src/main/kotlin"))
+    executionData.setFrom(fileTree(layout.buildDirectory) {
+        include("jacoco/testDebugUnitTest.exec")
+    })
+}
+
+tasks.register<JacocoCoverageVerification>("jacocoTestCoverageVerification") {
+    dependsOn("jacocoTestReport")
+
+    val debugTree = fileTree("${layout.buildDirectory.get()}/tmp/kotlin-classes/debug") {
+        exclude(jacocoExcludes)
+    }
+
+    classDirectories.setFrom(debugTree)
+    sourceDirectories.setFrom(files("src/main/kotlin"))
+    executionData.setFrom(fileTree(layout.buildDirectory) {
+        include("jacoco/testDebugUnitTest.exec")
+    })
+
+    violationRules {
+        rule {
+            limit {
+                minimum = "0.80".toBigDecimal()
+            }
+        }
+    }
+}
```

> **Implementation Note on Class Directory**: The path `tmp/kotlin-classes/debug` is the standard location for Kotlin-compiled class files in Android Gradle builds. At implementation time, verify this path by running `./gradlew testDebugUnitTest` and checking the actual output directory. If the path differs (e.g., `intermediates/javac/debug/classes`), adjust accordingly.

> **Implementation Note on Jacoco Version**: Version `0.8.12` is the latest at knowledge cutoff. Verify the latest stable version at https://www.jacoco.org/jacoco/ at implementation time.

---

## User Story 4: CI/CD Pipeline Finalization

**As a** developer or maintainer of the Android Remote Control MCP project
**I want** a complete CI/CD pipeline that runs lint, unit tests, integration tests, E2E tests, coverage reporting, and APK builds
**So that** every push and pull request is automatically validated for correctness, quality, and buildability.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] CI pipeline has 5 jobs: lint, test-unit, test-integration, test-e2e, build-release
- [ ] `lint` job runs ktlint and detekt
- [ ] `test-unit` job runs unit tests and uploads Jacoco coverage report
- [ ] `test-integration` job uses `reactivecircus/android-emulator-runner` with API 34, x86_64, google_apis
- [ ] `test-e2e` job runs `./gradlew :e2e-tests:test` (Docker is available on GitHub Actions runners)
- [ ] `build-release` job builds debug and release APKs and uploads as artifacts
- [ ] Job dependency chain: lint -> test-unit -> test-integration -> test-e2e -> build-release (sequential as per CLAUDE.md)
- [ ] All jobs use `actions/setup-java@v4` with Java 17 (temurin) and `gradle/actions/setup-gradle@v4`
- [ ] Concurrency group cancels previous runs on same branch
- [ ] `gh act --validate` passes
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 5 | `chore: finalize CI/CD pipeline with all test jobs` | Updated `.github/workflows/ci.yml` |

---

### Task 10.9: Finalize CI/CD Pipeline

**Description**: Replace the stub CI workflow (from Plan 1) with the full pipeline including integration tests, E2E tests, and Jacoco coverage upload.

**Acceptance Criteria**:
- [ ] `lint` job: checkout, setup-java, setup-gradle, ktlintCheck, detekt
- [ ] `test-unit` job: depends on lint; runs `./gradlew :app:test jacocoTestReport` (only app module unit tests); uploads test results and coverage report
- [ ] `test-integration` job: depends on test-unit; uses `reactivecircus/android-emulator-runner@v2` with api-level 34, arch x86_64, target google_apis; runs `./gradlew :app:connectedAndroidTest`; uploads test results
- [ ] `test-e2e` job: depends on test-integration; builds debug APK first; runs `./gradlew :e2e-tests:test`; uploads test results
- [ ] `build-release` job: depends on test-e2e; builds debug + release APKs; uploads as artifacts
- [ ] All jobs have `timeout-minutes` set appropriately
- [ ] `gh act --validate` passes

**Tests**: `gh act --validate` for workflow syntax. `gh act -n push` for dry-run.

#### Action 10.9.1: Update `.github/workflows/ci.yml`

**What**: Replace the stub CI workflow with the full pipeline.

**Context**: Plan 1 created a stub CI with lint, test-unit, and build jobs. The integration and E2E jobs were commented out stubs. This action replaces the entire file with the full pipeline. The `reactivecircus/android-emulator-runner` GitHub Action provides a pre-configured Android emulator for integration tests. Docker is pre-installed on `ubuntu-latest` GitHub Actions runners, so Testcontainers works out of the box for E2E tests.

**File**: `.github/workflows/ci.yml`

```diff
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ Replace entire file contents
+name: CI
+
+on:
+  push:
+    branches: [main]
+  pull_request:
+    branches: [main]
+
+concurrency:
+  group: ${{ github.workflow }}-${{ github.ref }}
+  cancel-in-progress: true
+
+jobs:
+  lint:
+    name: Lint
+    runs-on: ubuntu-latest
+    timeout-minutes: 15
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          java-version: '17'
+          distribution: 'temurin'
+
+      - name: Set up Gradle
+        uses: gradle/actions/setup-gradle@v4
+
+      - name: Run ktlint
+        run: ./gradlew ktlintCheck
+
+      - name: Run detekt
+        run: ./gradlew detekt
+
+  test-unit:
+    name: Unit Tests
+    runs-on: ubuntu-latest
+    needs: lint
+    timeout-minutes: 20
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          java-version: '17'
+          distribution: 'temurin'
+
+      - name: Set up Gradle
+        uses: gradle/actions/setup-gradle@v4
+
+      - name: Run unit tests with coverage
+        run: ./gradlew :app:test jacocoTestReport
+
+      - name: Upload unit test results
+        if: always()
+        uses: actions/upload-artifact@v4
+        with:
+          name: unit-test-results
+          path: app/build/reports/tests/
+          retention-days: 14
+
+      - name: Upload Jacoco coverage report
+        if: always()
+        uses: actions/upload-artifact@v4
+        with:
+          name: coverage-report
+          path: |
+            app/build/reports/jacoco/jacocoTestReport/html/
+            app/build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml
+          retention-days: 14
+
+  test-integration:
+    name: Integration Tests
+    runs-on: ubuntu-latest
+    needs: test-unit
+    timeout-minutes: 45
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          java-version: '17'
+          distribution: 'temurin'
+
+      - name: Set up Gradle
+        uses: gradle/actions/setup-gradle@v4
+
+      - name: Run integration tests
+        uses: reactivecircus/android-emulator-runner@v2
+        with:
+          api-level: 34
+          arch: x86_64
+          target: google_apis
+          force-avd-creation: false
+          emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim
+          disable-animations: true
+          script: ./gradlew :app:connectedAndroidTest
+
+      - name: Upload integration test results
+        if: always()
+        uses: actions/upload-artifact@v4
+        with:
+          name: integration-test-results
+          path: app/build/reports/androidTests/connected/
+          retention-days: 14
+
+  test-e2e:
+    name: E2E Tests
+    runs-on: ubuntu-latest
+    needs: test-integration
+    timeout-minutes: 30
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          java-version: '17'
+          distribution: 'temurin'
+
+      - name: Set up Gradle
+        uses: gradle/actions/setup-gradle@v4
+
+      - name: Build debug APK (required by E2E tests)
+        run: ./gradlew assembleDebug
+
+      - name: Run E2E tests
+        run: ./gradlew :e2e-tests:test
+
+      - name: Upload E2E test results
+        if: always()
+        uses: actions/upload-artifact@v4
+        with:
+          name: e2e-test-results
+          path: e2e-tests/build/reports/tests/
+          retention-days: 14
+
+  build-release:
+    name: Build Release
+    runs-on: ubuntu-latest
+    needs: test-e2e
+    timeout-minutes: 20
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up JDK 17
+        uses: actions/setup-java@v4
+        with:
+          java-version: '17'
+          distribution: 'temurin'
+
+      - name: Set up Gradle
+        uses: gradle/actions/setup-gradle@v4
+
+      - name: Build debug APK
+        run: ./gradlew assembleDebug
+
+      - name: Build release APK
+        run: ./gradlew assembleRelease
+
+      - name: Upload debug APK
+        uses: actions/upload-artifact@v4
+        with:
+          name: app-debug
+          path: app/build/outputs/apk/debug/app-debug.apk
+          retention-days: 30
+
+      - name: Upload release APK
+        uses: actions/upload-artifact@v4
+        with:
+          name: app-release
+          path: app/build/outputs/apk/release/app-release-unsigned.apk
+          retention-days: 30
```

> **Implementation Note on `reactivecircus/android-emulator-runner`**: At implementation time, verify the latest version of this action (currently `@v2`). Also verify that `api-level: 34` with `target: google_apis` and `arch: x86_64` is supported. Some API levels may require `target: default` or `target: google_apis_playstore`. Check the action's documentation.

> **Implementation Note on `gh act` Limitations**: The `nektos/act` tool (used via `gh act`) runs GitHub Actions workflows locally in Docker containers. However:
> - The `reactivecircus/android-emulator-runner` action requires KVM (hardware acceleration) which may not be available inside Docker (Docker-in-Docker with KVM passthrough is complex).
> - The `test-e2e` job requires Docker-in-Docker (the E2E tests start Docker containers via Testcontainers).
> - Therefore, `gh act` can validate syntax (`gh act --validate`) and do dry runs (`gh act -n push`), but cannot fully execute the `test-integration` or `test-e2e` jobs locally.
> - For local testing: run `make test-unit` (works everywhere), `make test-integration` (requires local emulator), `make test-e2e` (requires Docker).

---

## User Story 5: README.md Finalization

**As a** potential user, contributor, or AI model developer discovering the Android Remote Control MCP project
**I want** comprehensive, well-organized, and inviting documentation in the README
**So that** I can quickly understand what the project does, how to build and configure it, how to connect MCP clients, and how to contribute.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] README has project title with badges (CI status, license)
- [ ] README has clear project description and purpose
- [ ] README has features list organized by category (all 29 MCP tools)
- [ ] README has requirements section (Android SDK, Java 17, Docker for E2E)
- [ ] README has Quick Start guide (build, install, configure, connect)
- [ ] README has Building section (debug + release)
- [ ] README has Testing section (unit, integration, E2E, coverage)
- [ ] README has MCP Tools overview with link to `docs/MCP_TOOLS.md`
- [ ] README has Architecture overview with link to `docs/ARCHITECTURE.md`
- [ ] README has Configuration section (server settings, HTTPS, binding address)
- [ ] README has Security section (HTTPS, bearer token, binding, permissions)
- [ ] README has Contributing section
- [ ] README has License section (MIT)
- [ ] README is well-formatted, user-friendly, and professional
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 6 | `docs: finalize README.md with complete project documentation` | `README.md` |

---

### Task 10.10: Finalize README.md

**Description**: Replace the README.md skeleton (from Plan 1) with complete, polished project documentation.

**Acceptance Criteria**:
- [ ] All sections from acceptance criteria are present and complete
- [ ] Badges render correctly (GitHub Actions CI, MIT license)
- [ ] Code examples are correct and copy-pasteable
- [ ] Internal links to `docs/` files are correct
- [ ] No placeholder text remaining
- [ ] Professional tone, clear language, well-organized

**Tests**: No automated tests for documentation.

#### Action 10.10.1: Update `README.md` with complete documentation

**What**: Replace the skeleton README with full project documentation.

**Context**: The README.md is the first thing users and contributors see. It should be welcoming, clear, and comprehensive. This replaces the skeleton from Plan 1 with complete content reflecting all 10 plans of implementation. The badges use GitHub's shields.io service. Internal links point to docs created in Plans 6 and 9.

**File**: `README.md`

```diff
--- a/README.md
+++ b/README.md
@@ Replace entire file contents
+# Android Remote Control MCP
+
+[![CI](https://github.com/danielealbano/android-remote-control-mcp/actions/workflows/ci.yml/badge.svg)](https://github.com/danielealbano/android-remote-control-mcp/actions/workflows/ci.yml)
+[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
+
+An Android application that runs as an **MCP (Model Context Protocol) server**, enabling AI models to **fully control an Android device** remotely using accessibility services and screenshot capture.
+
+The app runs directly on your Android device (or emulator) and exposes an HTTP server (with optional HTTPS) implementing the MCP protocol. AI models like Claude can connect to it and interact with any app on the device — reading UI elements, tapping buttons, typing text, swiping, capturing screenshots, and more.
+
+---
+
+## Features
+
+### MCP Server
+- HTTP server running directly on Android (Ktor + Netty), with optional HTTPS
+- JSON-RPC 2.0 protocol (MCP specification compliant)
+- Bearer token authentication
+- Auto-generated self-signed TLS certificates (or custom certificate upload)
+- Configurable binding: localhost (127.0.0.1) or network (0.0.0.0)
+- Auto-start on boot
+- Health check endpoint (`GET /health`)
+
+### 29 MCP Tools across 7 Categories
+
+| Category | Tools | Description |
+|----------|-------|-------------|
+| **Screen Introspection** (4) | `get_accessibility_tree`, `capture_screenshot`, `get_current_app`, `get_screen_info` | Read UI state and capture screenshots |
+| **System Actions** (6) | `press_back`, `press_home`, `press_recents`, `open_notifications`, `open_quick_settings`, `get_device_logs` | Global device actions and log retrieval |
+| **Touch Actions** (5) | `tap`, `long_press`, `double_tap`, `swipe`, `scroll` | Coordinate-based touch interactions |
+| **Gestures** (2) | `pinch`, `custom_gesture` | Multi-touch and complex gestures |
+| **Element Actions** (5) | `find_elements`, `click_element`, `long_click_element`, `set_text`, `scroll_to_element` | Accessibility node-based interactions |
+| **Text Input** (3) | `input_text`, `clear_text`, `press_key` | Keyboard input and text manipulation |
+| **Utilities** (4) | `get_clipboard`, `set_clipboard`, `wait_for_element`, `wait_for_idle` | Helper tools for automation |
+
+See [docs/MCP_TOOLS.md](docs/MCP_TOOLS.md) for full tool documentation with input/output schemas and examples.
+
+### Android App
+- Material Design 3 configuration UI with dark mode
+- Server status monitoring (running/stopped)
+- Connection info display (IP, port, token)
+- Permission management (Accessibility, MediaProjection)
+- Server log viewer
+
+---
+
+## Requirements
+
+### For Building
+- **JDK 17** (e.g., [Eclipse Temurin](https://adoptium.net/))
+- **Android SDK** with API 34 (Android 14)
+- **Gradle** 8.x (wrapper included, no global install needed)
+
+### For Running
+- Android device or emulator running **Android 8.0+** (API 26+), targeting **Android 14** (API 34)
+- **adb** (Android Debug Bridge) for device/emulator management
+
+### For E2E Tests
+- **Docker** (for `budtmo/docker-android-x86` emulator image)
+
+Check all dependencies:
+```bash
+make check-deps
+```
+
+---
+
+## Quick Start
+
+### 1. Build the App
+
+```bash
+git clone https://github.com/danielealbano/android-remote-control-mcp.git
+cd android-remote-control-mcp
+make build
+```
+
+### 2. Install on Device/Emulator
+
+```bash
+# Start an emulator (if no device connected)
+make setup-emulator
+make start-emulator
+
+# Install the debug APK
+make install
+```
+
+### 3. Configure Permissions
+
+1. **Enable Accessibility Service**: Open the app, tap "Enable Accessibility Service", and toggle it on in Android Settings.
+2. **Grant Screen Capture**: When prompted by the app, grant the MediaProjection permission.
+
+### 4. Start the MCP Server
+
+Tap the "Start Server" button in the app. The server starts on `http://127.0.0.1:8080` by default (HTTPS is disabled by default).
+
+### 5. Connect from Host Machine
+
+Set up port forwarding (if server is bound to localhost):
+```bash
+make forward-port
+```
+
+Test the connection:
+```bash
+curl http://localhost:8080/health
+```
+
+Expected response:
+```json
+{"status": "healthy", "version": "1.0.0", "server": "running"}
+```
+
+### 6. Make MCP Tool Calls
+
+```bash
+# List available tools
+curl -X POST http://localhost:8080/mcp/v1/tools/list \
+  -H "Authorization: Bearer YOUR_TOKEN" \
+  -H "Content-Type: application/json" \
+  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list"}'
+
+# Get the accessibility tree
+curl -X POST http://localhost:8080/mcp/v1/tools/call \
+  -H "Authorization: Bearer YOUR_TOKEN" \
+  -H "Content-Type: application/json" \
+  -d '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"get_accessibility_tree","arguments":{}}}'
+
+# Tap at coordinates
+curl -X POST http://localhost:8080/mcp/v1/tools/call \
+  -H "Authorization: Bearer YOUR_TOKEN" \
+  -H "Content-Type: application/json" \
+  -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"tap","arguments":{"x":540,"y":1200}}}'
+```
+
+The bearer token is displayed in the app's connection info section. You can copy it directly from the app.
+
+---
+
+## Building
+
+### Debug Build
+
+```bash
+make build
+# APK: app/build/outputs/apk/debug/app-debug.apk
+```
+
+### Release Build
+
+```bash
+make build-release
+# APK: app/build/outputs/apk/release/app-release.apk
+```
+
+For signed release builds, create `keystore.properties` in the project root:
+```properties
+storeFile=path/to/your.keystore
+storePassword=your_store_password
+keyAlias=your_key_alias
+keyPassword=your_key_password
+```
+
+### Clean Build
+
+```bash
+make clean
+```
+
+---
+
+## Testing
+
+### Unit Tests
+
+```bash
+make test-unit
+```
+
+Runs JUnit 5 unit tests with MockK for mocking. Tests cover MCP protocol handling, accessibility tree parsing, element finding, screenshot encoding, settings repository, network utilities, and all 29 MCP tool handlers.
+
+### Integration Tests
+
+```bash
+make test-integration
+```
+
+Requires a connected device or running emulator. Tests cover MainActivity UI interactions, Compose rendering, ViewModel-repository integration, and service binding.
+
+### E2E Tests
+
+```bash
+make test-e2e
+```
+
+Requires Docker. Starts a full Android emulator inside Docker, installs the app, and performs real MCP tool calls. Includes:
+- **Calculator test**: 7 + 3 = 10 via MCP tools (verifies full stack)
+- **Screenshot test**: Capture with different quality settings
+- **Error handling test**: Authentication, unknown tools, invalid params
+
+### All Tests
+
+```bash
+make test
+```
+
+### Code Coverage
+
+```bash
+make coverage
+```
+
+Generates a Jacoco HTML report at `app/build/reports/jacoco/jacocoTestReport/html/index.html`. Minimum coverage target: 80%.
+
+---
+
+## Architecture
+
+The application is a **service-based Android app** with four main components:
+
+1. **AccessibilityService** - UI introspection and action execution via Android Accessibility APIs
+2. **ScreenCaptureService** - Screenshot capture via MediaProjection
+3. **McpServerService** - Foreground service running the Ktor HTTP/HTTPS server
+4. **MainActivity** - Jetpack Compose UI for configuration and control
+
+```
+MCP Client (AI Model)
+    |
+    | HTTP/HTTPS + Bearer Token
+    v
+McpServerService (Ktor)
+    |
+    |--- McpProtocolHandler (JSON-RPC 2.0)
+    |       |
+    |       |--- 29 MCP Tool Handlers
+    |
+    |--- AccessibilityService
+    |       |--- AccessibilityTreeParser
+    |       |--- ElementFinder
+    |       |--- ActionExecutor
+    |
+    |--- ScreenCaptureService
+            |--- MediaProjection
+            |--- ScreenshotEncoder
+```
+
+See [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) for detailed architecture documentation.
+
+---
+
+## Configuration
+
+### Server Settings (via App UI)
+
+| Setting | Default | Description |
+|---------|---------|-------------|
+| Port | `8080` | HTTP/HTTPS server port |
+| Binding Address | `127.0.0.1` | `127.0.0.1` (localhost, use with adb port forwarding) or `0.0.0.0` (network, all interfaces) |
+| Bearer Token | Auto-generated UUID | Authentication token for MCP requests |
+| HTTPS | Disabled | Enable HTTPS with auto-generated self-signed certificate (configurable hostname) or upload custom .p12/.pfx |
+| Auto-start on Boot | Disabled | Start MCP server automatically when device boots |
+
+### Using with adb Port Forwarding (Recommended)
+
+When the server is bound to `127.0.0.1` (default, most secure):
+
+```bash
+# Forward device port to host
+adb forward tcp:8080 tcp:8080
+
+# Connect from host
+curl http://localhost:8080/health
+```
+
+### Using over Network
+
+When the server is bound to `0.0.0.0`:
+
+1. Find the device's IP address (shown in the app's connection info)
+2. Connect directly: `curl http://DEVICE_IP:8080/health`
+
+**Warning**: Binding to `0.0.0.0` exposes the server to all devices on the same network. Only use on trusted private networks.
+
+---
+
+## Security
+
+### HTTPS (Optional, Disabled by Default)
+- HTTPS can be enabled in the app settings for encrypted TLS communication
+- When enabled, uses auto-generated self-signed certificates (or upload your own CA-signed certificate)
+- Certificate is stored in app-private storage
+- Server defaults to HTTP; enable HTTPS when operating on untrusted networks
+
+### Bearer Token Authentication
+- Every MCP request requires `Authorization: Bearer <token>` header
+- Token is auto-generated on first launch (UUID)
+- Token can be viewed, copied, and regenerated in the app
+- Constant-time comparison prevents timing attacks
+
+### Binding Address
+- **Default `127.0.0.1`**: Only accessible via adb port forwarding (most secure)
+- **Optional `0.0.0.0`**: Accessible over network (use only on trusted networks)
+- Security warning dialog displayed when switching to network mode
+
+### Permissions
+- **Accessibility Service**: Required for UI introspection and actions (user must enable manually)
+- **MediaProjection**: Required for screenshots (one-time user grant)
+- **Internet**: For running the HTTP/HTTPS server
+- **Foreground Service**: For keeping services alive in background
+- No root access required
+
+---
+
+## Linting
+
+```bash
+# Check for issues
+make lint
+
+# Auto-fix issues
+make lint-fix
+```
+
+Uses ktlint for code style and detekt for static analysis.
+
+---
+
+## Contributing
+
+1. Fork the repository
+2. Create a feature branch: `git checkout -b feat/your-feature`
+3. Make your changes following the project conventions (see [docs/PROJECT.md](docs/PROJECT.md))
+4. Ensure all checks pass: `make lint && make test-unit && make build`
+5. Commit with descriptive messages (e.g., `feat: add new MCP tool for ...`)
+6. Open a pull request
+
+### Development Conventions
+
+- **Language**: Kotlin with Android (Jetpack Compose, Ktor)
+- **Architecture**: Service-based with SOLID principles
+- **Testing**: JUnit 5 + MockK (unit), AndroidX Test (integration), Testcontainers (E2E)
+- **Linting**: ktlint + detekt
+- **DI**: Hilt (Dagger-based)
+
+See [docs/PROJECT.md](docs/PROJECT.md) for the complete project bible.
+
+---
+
+## License
+
+This project is licensed under the MIT License. See [LICENSE](LICENSE) for details.
```

> **Implementation Note on Badges**: The badge URLs assume the GitHub repository is at `danielealbano/android-remote-control-mcp`. At implementation time, verify the correct repository owner and name. If the repository is in a different organization or has a different name, adjust the badge URLs.

---

## User Story 6: Makefile Updates

**As a** developer using the Makefile for daily workflow
**I want** the Makefile `coverage` target to work correctly with Jacoco and the `ci` target to include the full test suite
**So that** I can run coverage reports and simulate the CI pipeline locally.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] `make coverage` runs `./gradlew jacocoTestReport` and prints the report location
- [ ] `make ci` runs the full local CI sequence (check-deps, lint, test-unit, build-release)
- [ ] `make help` shows all targets correctly
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 7 | `chore: update Makefile for E2E and coverage targets` | `Makefile` |

---

### Task 10.11: Verify and Update Makefile Targets

**Description**: Verify that all Makefile targets defined in Plan 1 work correctly with the E2E module and Jacoco integration. The Makefile already has `test-e2e`, `coverage`, and `check-deps` targets from Plan 1. This task ensures they work correctly and updates the `ci` target to be more comprehensive.

**Acceptance Criteria**:
- [ ] `make test-e2e` runs `./gradlew :e2e-tests:test` (already defined in Plan 1)
- [ ] `make coverage` runs `./gradlew jacocoTestReport` (already defined in Plan 1)
- [ ] `make check-deps` includes Docker check (already defined in Plan 1)
- [ ] `make ci` updated to include coverage generation
- [ ] No changes needed for other targets (they are already correct from Plan 1)

**Tests**: `make help` runs without error.

#### Action 10.11.1: Update Makefile `ci` target to include coverage

**What**: Update the `ci` target to also generate the coverage report after unit tests.

**Context**: The current `ci` target (from Plan 1) runs `check-deps lint test-unit build-release`. After adding Jacoco, we should also generate the coverage report as part of the CI sequence. The `coverage` target already exists and runs `jacocoTestReport`.

**File**: `Makefile`

```diff
--- a/Makefile
+++ b/Makefile
@@ The ci target, near the end of the file
-ci: check-deps lint test-unit build-release ## Run CI workflow
+ci: check-deps lint test-unit coverage build-release ## Run CI workflow
```

---

## Verification Plan

After all tasks are implemented, run the following verification sequence:

### Verification Step 1: Lint

```bash
make lint
```

Expected: No errors, no warnings.

### Verification Step 2: Unit Tests

```bash
make test-unit
```

Expected: All unit tests pass (including tests from Plans 2-9).

### Verification Step 3: Build

```bash
make build
```

Expected: Build succeeds with no errors, no warnings.

### Verification Step 4: Coverage Report

```bash
make coverage
```

Expected: Jacoco report generated at `app/build/reports/jacoco/jacocoTestReport/html/index.html`.

### Verification Step 5: CI Workflow Validation

```bash
gh act --validate
```

Expected: CI workflow YAML syntax is valid.

### Verification Step 6: CI Dry Run

```bash
gh act -n push
```

Expected: Dry run completes showing all jobs would execute.

### Verification Step 7: E2E Tests (if Docker available)

```bash
make test-e2e
```

Expected: All E2E tests pass (Calculator 7+3=10, screenshot, error handling).

### Verification Step 8: README Rendering

Open `README.md` in a Markdown viewer or on GitHub and verify:
- Badges render correctly
- All sections are present and well-formatted
- Code examples are correct
- Internal links work

---

## Performance, Security, and QA Review

### Performance Considerations

1. **E2E test runtime**: All E2E test classes share a single Docker container via the `SharedAndroidContainer` singleton. The container boots once (~2-4 min) and is reused across all test classes (Calculator, Screenshot, ErrorHandling). Total E2E runtime is ~5-7 minutes instead of ~10-15 minutes with per-class containers. A JVM shutdown hook ensures the container is stopped when all tests complete.

2. **CI pipeline sequential chain**: The pipeline follows the CLAUDE.md mandated chain: `lint -> test-unit -> test-integration -> test-e2e -> build-release`. This is sequential, which increases total CI time but ensures each stage only runs after all prerequisite stages pass. This matches the project's quality gate philosophy where later stages depend on earlier stage success.

3. **Jacoco overhead**: Jacoco instrumentation adds ~5-10% overhead to test execution. This is negligible for unit tests.

4. **Docker image size**: The `budtmo/docker-android-x86:emulator_14.0` image is large (~5-8 GB). On GitHub Actions, images are pulled fresh each run (no caching). Consider using Docker layer caching (`docker/setup-buildx-action`) in a future optimization.

### Security Considerations

1. **Trust-all-certs in E2E tests**: The `McpClient` uses a `TrustManager` that accepts all certificates. This is confined to the `e2e-tests` module (test code only, never in production). The OkHttp dependency is `testImplementation` only.

2. **Bearer token in E2E tests**: The E2E tests use a hardcoded known bearer token (`e2e-test-token-12345`). This is only used in test environments and is not a real security credential. It is not committed to any production configuration.

3. **Docker privileged mode**: The Docker Android container runs in privileged mode (`withPrivilegedMode(true)`) because the Android emulator requires KVM access. This is a security consideration for CI environments. GitHub Actions runners are ephemeral, so the risk is mitigated.

4. **CI secrets**: The CI pipeline does not use any secrets for the base configuration. Release signing (if configured) would require GitHub Secrets for the keystore. This is not configured in this plan but documented as a future step.

### QA Considerations

1. **Calculator app variation**: The AOSP Calculator app's UI varies across Android versions and device manufacturers. The E2E tests use flexible matching (contains search, fallback to content_desc) to be resilient. At implementation time, verify the exact Calculator package name and button text/descriptions on the Docker Android emulator.

2. **Flaky E2E tests**: E2E tests involving UI interaction and container startup can be flaky. The tests include:
   - Retry logic in `findElementWithRetry()` (polls up to 10 seconds)
   - Generous timeouts for container boot (180s) and server ready (60s)
   - `Thread.sleep()` between actions (500ms-2s) to allow UI to settle
   - `wait_for_idle` call after calculation to ensure result is rendered

3. **DataStore configuration in E2E**: The `configureServerSettings()` method uses a debug-only `BroadcastReceiver` (`E2EConfigReceiver`) to inject test settings (bearer token, binding address, port) via `adb shell am broadcast`. This requires adding the receiver to the app's debug source set as a prerequisite. The approach is reliable because it uses the app's own `SettingsRepository` for validation and persistence.

4. **Coverage threshold**: The 80% minimum coverage threshold is enforced via `jacocoTestCoverageVerification`. If coverage drops below 80%, the build will fail. This is intentional to maintain code quality. The threshold can be adjusted if needed (discuss with the user).

---

## Summary of All Files

### New Files

| File | Task | Description |
|------|------|-------------|
| `e2e-tests/build.gradle.kts` | 10.2 | E2E test module build configuration |
| `e2e-tests/src/test/kotlin/.../e2e/McpClient.kt` | 10.3 | MCP JSON-RPC client for E2E tests |
| `e2e-tests/src/test/kotlin/.../e2e/AndroidContainerSetup.kt` | 10.4 | Docker Android container management |
| `e2e-tests/src/test/kotlin/.../e2e/SharedAndroidContainer.kt` | 10.4.2 | Singleton shared container for all E2E test classes |
| `e2e-tests/src/test/kotlin/.../e2e/E2ECalculatorTest.kt` | 10.5 | Calculator E2E test (7 + 3 = 10) |
| `e2e-tests/src/test/kotlin/.../e2e/E2EScreenshotTest.kt` | 10.6 | Screenshot capture E2E test |
| `e2e-tests/src/test/kotlin/.../e2e/E2EErrorHandlingTest.kt` | 10.7 | Error handling E2E test |
| `app/src/debug/kotlin/.../debug/E2EConfigReceiver.kt` | 10.4.1b | Debug-only BroadcastReceiver for E2E test configuration |
| `app/src/debug/AndroidManifest.xml` | 10.4.1b | Debug-only manifest overlay registering E2EConfigReceiver |

### Modified Files

| File | Task | Description |
|------|------|-------------|
| `gradle/libs.versions.toml` | 10.1 | Add OkHttp dependency |
| `settings.gradle.kts` | 10.2 | Include `:e2e-tests` module |
| `app/build.gradle.kts` | 10.8 | Add Jacoco plugin and configuration |
| `.github/workflows/ci.yml` | 10.9 | Full CI pipeline with all jobs |
| `README.md` | 10.10 | Complete project documentation |
| `Makefile` | 10.11 | Update `ci` target to include coverage |

---

**End of Plan 10**
