# Plan 6: MCP Server (Ktor + Protocol + Auth + HTTPS)

**Branch**: `feat/mcp-server-ktor`
**PR Title**: `Plan 6: MCP Server with Ktor, HTTPS, authentication, and protocol handler`
**Created**: 2026-02-11 16:32:14

---

## Overview

This plan implements the MCP server infrastructure: the McpServerService foreground service, Ktor HTTP server with optional HTTPS/SSL certificate management, MCP JSON-RPC 2.0 protocol handler, bearer token authentication, health endpoint, boot receiver, and inter-service wiring. It also creates the `docs/ARCHITECTURE.md` documentation.

### Dependencies on Previous Plans

- **Plan 1**: Project scaffolding, Gradle build system, all dependencies in `libs.versions.toml` (Ktor, MCP SDK, kotlinx-serialization), `AndroidManifest.xml` with McpServerService, ScreenCaptureService, BootCompletedReceiver declarations, stub `McpApplication.kt`, `AppModule.kt`
- **Plan 2**: `ServerConfig` data class, `ServerStatus` sealed class, `SettingsRepository` interface and implementation, `BindingAddress` enum, `CertificateSource` enum, `NetworkUtils`, `PermissionUtils`, `Logger`, Hilt bindings in `AppModule`
- **Plan 3**: `MainViewModel` with stub `startServer()`/`stopServer()`, `MainActivity`, `HomeScreen`, all Compose UI components
- **Plan 4**: `McpAccessibilityService`, `AccessibilityTreeParser`, `ElementFinder`, `ActionExecutor`
- **Plan 5**: `ScreenCaptureService`, `ScreenshotEncoder`, MediaProjection lifecycle management

### Package Base

`com.danielealbano.androidremotecontrolmcp`

### Path References

- **Source root**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/`
- **Test root**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/`
- **Resources**: `app/src/main/res/`

### MCP Kotlin SDK Evaluation Note

At implementation time, the official **MCP Kotlin SDK** (`io.modelcontextprotocol:kotlin-sdk`) MUST be evaluated before implementing custom JSON-RPC handling. Check:

1. Does the SDK support server-side (not just client-side) operation?
2. Does it support HTTP/HTTPS transport (not just stdio)?
3. Does it provide tool registration and invocation framework compatible with our Ktor server?
4. Is it compatible with Android (no JVM-only dependencies)?

If the SDK fits, use it instead of the custom `McpProtocolHandler` described below. If the SDK does not fit (e.g., it is designed for MCP clients, only supports stdio transport, or has JVM-only dependencies incompatible with Android), implement the custom protocol handling as described in this plan. Document the evaluation decision in a code comment in `McpProtocolHandler.kt`.

---

## User Story 1: MCP Server Infrastructure

**As a** user of the Android Remote Control MCP application
**I want** an MCP server (HTTP by default, with optional HTTPS) running as an Android foreground service with JSON-RPC 2.0 protocol support and bearer token authentication
**So that** AI models can connect to my device and execute MCP tool calls to control the Android device remotely.

### Acceptance Criteria / Definition of Done (High Level)

- [ ] `McpProtocolHandler` correctly parses JSON-RPC 2.0 requests and produces valid responses
- [ ] `McpProtocolHandler` handles `initialize`, `tools/list`, and `tools/call` methods
- [ ] `McpProtocolHandler` returns correct error codes for all error conditions (-32700 through -32004)
- [ ] `McpProtocolHandler` supports tool registration via `registerTool()` and `ToolHandler` interface
- [ ] `BearerTokenAuth` intercepts all `/mcp/*` routes and validates bearer token
- [ ] `BearerTokenAuth` uses constant-time comparison (`MessageDigest.isEqual()`) to prevent timing attacks
- [ ] `BearerTokenAuth` skips authentication for `/health` endpoint
- [ ] `BearerTokenAuth` returns 401 Unauthorized for missing/invalid tokens
- [ ] `CertificateManager` generates self-signed RSA 2048-bit X.509 certificates with CN and SAN
- [ ] `CertificateManager` generates certificates valid for 1 year
- [ ] `CertificateManager` loads existing keystore or generates new one on first use
- [ ] `CertificateManager` imports custom `.p12`/`.pfx` certificates with password validation
- [ ] `CertificateManager` rejects expired custom certificates
- [ ] `McpServer` configures Ktor Netty with HTTP by default and optional HTTPS (when HTTPS is enabled in settings)
- [ ] `McpServer` installs ContentNegotiation with JSON, routing, and status pages
- [ ] `McpServer` routes: `GET /health`, `POST /mcp/v1/initialize`, `GET /mcp/v1/tools/list`, `POST /mcp/v1/tools/call`
- [ ] Health endpoint returns `{"status":"healthy","version":"<BuildConfig.VERSION_NAME>","server":"running"}` with HTTP 200
- [ ] Health endpoint is unauthenticated
- [ ] `McpServerService` is a foreground service with notification on channel `mcp_server_channel`
- [ ] `McpServerService` calls `startForeground()` within 5 seconds of start
- [ ] `McpServerService` reads config from `SettingsRepository` and starts `McpServer`
- [ ] `McpServerService` binds to `ScreenCaptureService` via `ServiceConnection`
- [ ] `McpServerService` publishes status updates via companion-level `StateFlow<ServerStatus>` (replaces deprecated `LocalBroadcastManager`)
- [ ] `McpServerService` handles graceful shutdown in `onDestroy()` (5s timeout)
- [ ] `BootCompletedReceiver` starts `McpServerService` if auto-start is enabled in settings
- [ ] `MainViewModel` wires `startServer()`/`stopServer()` to real `McpServerService` intents
- [ ] `MainViewModel` collects server status from `McpServerService.serverStatus` StateFlow and updates local `serverStatus` StateFlow
- [ ] `MainActivity` calls `viewModel.refreshPermissionStatus(this)` in `onResume()`
- [ ] `McpApplication` creates notification channels (`mcp_server_channel`, `screen_capture_channel`)
- [ ] `tools/list` returns empty list (no tools registered yet, tools added in Plans 7-9)
- [ ] `tools/call` returns method-not-found error for any tool name (no tools registered yet)
- [ ] Unit tests pass for `McpProtocolHandler`, `BearerTokenAuth`, `CertificateManager`
- [ ] `make lint` passes with no errors or warnings
- [ ] `make build` succeeds with no errors or warnings
- [ ] `make test-unit` passes

### Commit Strategy

| # | Message | Files |
|---|---------|-------|
| 1 | `feat: add MCP protocol handler with JSON-RPC 2.0 support` | `McpProtocolHandler.kt` |
| 2 | `feat: add bearer token authentication middleware` | `BearerTokenAuth.kt` |
| 3 | `feat: add SSL certificate manager with self-signed and custom cert support` | `CertificateManager.kt` |
| 4 | `feat: add Ktor MCP server with HTTPS and routing` | `McpServer.kt` |
| 5 | `feat: add McpServerService foreground service and BootCompletedReceiver` | `McpServerService.kt`, `BootCompletedReceiver.kt` |
| 6 | `feat: wire server lifecycle to UI and add notification channels` | Updated `MainViewModel.kt`, `MainActivity.kt`, `McpApplication.kt` |
| 7 | `test: add unit tests for protocol handler, auth, and certificate manager` | `McpProtocolHandlerTest.kt`, `BearerTokenAuthTest.kt`, `CertificateManagerTest.kt` |
| 8 | `docs: add application architecture documentation` | `docs/ARCHITECTURE.md` |

> **CRITICAL — Task ordering**: Task 6.7 (add Bouncy Castle dependency) MUST be executed BEFORE Task 6.3 (CertificateManager) because CertificateManager imports Bouncy Castle classes. Implement Task 6.7 first, then proceed with Task 6.3.

---

### Task 6.1: Create MCP Protocol Handler

**Description**: Create the `McpProtocolHandler` class that implements JSON-RPC 2.0 request parsing, method routing, tool registration, and all standard/custom error code factories. This is the core protocol layer that sits between Ktor routing and tool implementations.

**Acceptance Criteria**:
- [ ] `JsonRpcRequest`, `JsonRpcResponse`, `JsonRpcError` data classes are `@Serializable`
- [ ] `ToolHandler` interface defines `suspend fun execute(params: JsonObject?): JsonElement`
- [ ] `handleRequest()` routes to `handleInitialize()`, `handleToolsList()`, `handleToolCall()` based on method
- [ ] `handleInitialize()` returns server info (name, version) and capabilities (tools supported)
- [ ] `handleToolsList()` returns list of registered tools (empty initially)
- [ ] `handleToolCall()` dispatches to registered `ToolHandler` or returns method-not-found
- [ ] `registerTool()` adds tool name, description, input schema, and handler to the registry
- [ ] All error factory methods return correct JSON-RPC error codes (-32700 through -32004)
- [ ] File compiles without errors
- [ ] File passes ktlint and detekt

**Tests**: Unit tests in Task 6.8 (`McpProtocolHandlerTest.kt`).

#### Action 6.1.1: Create `McpProtocolHandler.kt`

**What**: Create the MCP JSON-RPC 2.0 protocol handler with request routing, tool registry, and error factories.

**Context**: This class is the central protocol handler. It receives parsed `JsonRpcRequest` objects from the Ktor routing layer (Task 6.4) and returns `JsonRpcResponse` objects. Tools are registered via `registerTool()` by Plans 7-9. The `ToolHandler` interface allows each tool category to implement its own handler. The `ToolDefinition` data class holds the tool metadata (name, description, inputSchema) for the `tools/list` response. Error codes follow the MCP specification defined in PROJECT.md. The handler is thread-safe using a `ConcurrentHashMap` for the tool registry.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpProtocolHandler.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpProtocolHandler.kt
@@ -0,0 +1,224 @@
+package com.danielealbano.androidremotecontrolmcp.mcp
+
+import android.util.Log
+import kotlinx.serialization.Serializable
+import kotlinx.serialization.json.JsonElement
+import kotlinx.serialization.json.JsonObject
+import kotlinx.serialization.json.JsonPrimitive
+import kotlinx.serialization.json.buildJsonObject
+import kotlinx.serialization.json.put
+import kotlinx.serialization.json.putJsonArray
+import kotlinx.serialization.json.putJsonObject
+import java.util.concurrent.ConcurrentHashMap
+import javax.inject.Inject
+import javax.inject.Singleton
+
+/**
+ * Handler interface for individual MCP tools.
+ *
+ * Each tool category (touch actions, element actions, etc.) implements this
+ * interface. Implementations are registered via [McpProtocolHandler.registerTool].
+ */
+interface ToolHandler {
+    /**
+     * Executes the tool with the given parameters.
+     *
+     * @param params The JSON parameters from the MCP tool call, or null if none provided.
+     * @return The result as a [JsonElement] to be included in the JSON-RPC response.
+     */
+    suspend fun execute(params: JsonObject?): JsonElement
+}
+
+/**
+ * Metadata for a registered MCP tool, used in the tools/list response.
+ *
+ * @property name The unique tool name (e.g., "tap", "get_accessibility_tree").
+ * @property description Human-readable description of what the tool does.
+ * @property inputSchema JSON Schema describing the tool's input parameters.
+ * @property handler The handler that executes this tool.
+ */
+data class ToolDefinition(
+    val name: String,
+    val description: String,
+    val inputSchema: JsonObject,
+    val handler: ToolHandler,
+)
+
+/**
+ * JSON-RPC 2.0 request.
+ */
+@Serializable
+data class JsonRpcRequest(
+    val jsonrpc: String = JSON_RPC_VERSION,
+    val id: JsonElement? = null,
+    val method: String,
+    val params: JsonObject? = null,
+)
+
+/**
+ * JSON-RPC 2.0 response.
+ */
+@Serializable
+data class JsonRpcResponse(
+    val jsonrpc: String = JSON_RPC_VERSION,
+    val id: JsonElement? = null,
+    val result: JsonElement? = null,
+    val error: JsonRpcError? = null,
+)
+
+/**
+ * JSON-RPC 2.0 error object.
+ */
+@Serializable
+data class JsonRpcError(
+    val code: Int,
+    val message: String,
+    val data: JsonElement? = null,
+)
+
+private const val JSON_RPC_VERSION = "2.0"
+
+/**
+ * Handles MCP JSON-RPC 2.0 requests by routing methods to appropriate handlers.
+ *
+ * Supports tool registration via [registerTool] and dispatches tool calls to
+ * the registered [ToolHandler] instances. Thread-safe via [ConcurrentHashMap].
+ *
+ * If the official MCP Kotlin SDK supports server-side HTTP transport and is
+ * Android-compatible, this class should be replaced with the SDK's built-in
+ * protocol handling. See the SDK evaluation note in the plan document.
+ */
+@Singleton
+class McpProtocolHandler @Inject constructor() {
+
+    private val tools = ConcurrentHashMap<String, ToolDefinition>()
+
+    /**
+     * Registers a tool with the protocol handler.
+     *
+     * @param name Unique tool name.
+     * @param description Human-readable description.
+     * @param inputSchema JSON Schema for the tool's input parameters.
+     * @param handler The handler that executes this tool.
+     */
+    fun registerTool(
+        name: String,
+        description: String,
+        inputSchema: JsonObject,
+        handler: ToolHandler,
+    ) {
+        tools[name] = ToolDefinition(name, description, inputSchema, handler)
+        Log.d(TAG, "Registered tool: $name")
+    }
+
+    /**
+     * Routes a JSON-RPC request to the appropriate handler method.
+     *
+     * @param request The parsed JSON-RPC request.
+     * @return The JSON-RPC response.
+     */
+    suspend fun handleRequest(request: JsonRpcRequest): JsonRpcResponse {
+        if (request.jsonrpc != JSON_RPC_VERSION) {
+            return invalidRequest(request.id, "Unsupported JSON-RPC version: ${request.jsonrpc}")
+        }
+
+        return when (request.method) {
+            METHOD_INITIALIZE -> handleInitialize(request)
+            METHOD_TOOLS_LIST -> handleToolsList(request)
+            METHOD_TOOLS_CALL -> handleToolCall(request)
+            else -> methodNotFound(request.id, request.method)
+        }
+    }
+
+    private fun handleInitialize(request: JsonRpcRequest): JsonRpcResponse {
+        val result = buildJsonObject {
+            put("protocolVersion", PROTOCOL_VERSION)
+            putJsonObject("serverInfo") {
+                put("name", SERVER_NAME)
+                put("version", SERVER_VERSION)
+            }
+            putJsonObject("capabilities") {
+                putJsonObject("tools") {
+                    put("listChanged", false)
+                }
+            }
+        }
+        return JsonRpcResponse(id = request.id, result = result)
+    }
+
+    private fun handleToolsList(request: JsonRpcRequest): JsonRpcResponse {
+        val result = buildJsonObject {
+            putJsonArray("tools") {
+                tools.values.forEach { tool ->
+                    add(buildJsonObject {
+                        put("name", tool.name)
+                        put("description", tool.description)
+                        put("inputSchema", tool.inputSchema)
+                    })
+                }
+            }
+        }
+        return JsonRpcResponse(id = request.id, result = result)
+    }
+
+    private suspend fun handleToolCall(request: JsonRpcRequest): JsonRpcResponse {
+        val params = request.params
+            ?: return invalidParams(request.id, "Missing params for tools/call")
+
+        val toolName = (params["name"] as? JsonPrimitive)?.content
+            ?: return invalidParams(request.id, "Missing 'name' in params")
+
+        val toolDef = tools[toolName]
+            ?: return methodNotFound(request.id, toolName)
+
+        val toolArgs = params["arguments"] as? JsonObject
+
+        return try {
+            val result = toolDef.handler.execute(toolArgs)
+            JsonRpcResponse(id = request.id, result = result)
+        } catch (e: Exception) {
+            Log.e(TAG, "Tool execution failed: $toolName", e)
+            internalError(request.id, "Tool execution failed: ${e.message ?: "Unknown error"}")
+        }
+    }
+
+    // --- Error factory methods ---
+
+    fun parseError(id: JsonElement?): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_PARSE, message = "Parse error: invalid JSON"),
+    )
+
+    fun invalidRequest(id: JsonElement?, message: String = "Invalid request"): JsonRpcResponse =
+        JsonRpcResponse(
+            id = id,
+            error = JsonRpcError(code = ERROR_INVALID_REQUEST, message = message),
+        )
+
+    fun methodNotFound(id: JsonElement?, method: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_METHOD_NOT_FOUND, message = "Method not found: $method"),
+    )
+
+    fun invalidParams(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_INVALID_PARAMS, message = message),
+    )
+
+    fun internalError(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_INTERNAL, message = message),
+    )
+
+    fun permissionDenied(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(
+            code = ERROR_PERMISSION_DENIED,
+            message = message,
+            data = buildJsonObject {
+                put("details", message)
+            },
+        ),
+    )
+
+    fun elementNotFound(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_ELEMENT_NOT_FOUND, message = message),
+    )
+
+    fun actionFailed(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_ACTION_FAILED, message = message),
+    )
+
+    fun timeoutError(id: JsonElement?, message: String): JsonRpcResponse = JsonRpcResponse(
+        id = id,
+        error = JsonRpcError(code = ERROR_TIMEOUT, message = message),
+    )
+
+    companion object {
+        private const val TAG = "MCP:ProtocolHandler"
+
+        const val METHOD_INITIALIZE = "initialize"
+        const val METHOD_TOOLS_LIST = "tools/list"
+        const val METHOD_TOOLS_CALL = "tools/call"
+
+        const val PROTOCOL_VERSION = "2024-11-05"
+        const val SERVER_NAME = "android-remote-control-mcp"
+        const val SERVER_VERSION = "1.0.0" // see implementation note below

> **Implementation Note**: `SERVER_VERSION` is hardcoded as "1.0.0" while the health endpoint uses `BuildConfig.VERSION_NAME`. At implementation time, use `BuildConfig.VERSION_NAME` for both to avoid divergence.
+
+        // Standard JSON-RPC error codes
+        const val ERROR_PARSE = -32700
+        const val ERROR_INVALID_REQUEST = -32600
+        const val ERROR_METHOD_NOT_FOUND = -32601
+        const val ERROR_INVALID_PARAMS = -32602
+        const val ERROR_INTERNAL = -32603
+
+        // Custom MCP error codes
+        const val ERROR_PERMISSION_DENIED = -32001
+        const val ERROR_ELEMENT_NOT_FOUND = -32002
+        const val ERROR_ACTION_FAILED = -32003
+        const val ERROR_TIMEOUT = -32004
+    }
+}
```

> **Implementation Note on `SERVER_VERSION`**: The `SERVER_VERSION` constant is hardcoded as `"1.0.0"` here. At implementation time, consider reading it from `BuildConfig.VERSION_NAME` if the class has access to the application context, or pass it as a constructor parameter. Since this is a `@Singleton` injected by Hilt, the version could be provided via a `@Named("appVersion")` string binding in `AppModule`.

> **Implementation Note on MCP protocol version**: The `PROTOCOL_VERSION` is set to `"2024-11-05"` which is the latest MCP specification version at the time of writing. Verify the latest protocol version at implementation time from the official MCP specification.

---

### Task 6.2: Create Bearer Token Authentication Middleware

**Description**: Create the `BearerTokenAuth` Ktor plugin/interceptor that authenticates all `/mcp/*` requests using bearer token from the `Authorization` header. Uses constant-time comparison to prevent timing attacks.

**Acceptance Criteria**:
- [ ] Intercepts all requests to `/mcp/*` routes
- [ ] Extracts token from `Authorization: Bearer <token>` header
- [ ] Validates token using `MessageDigest.isEqual()` (constant-time comparison)
- [ ] Returns 401 Unauthorized with JSON body for missing or invalid tokens
- [ ] Skips authentication for `/health` endpoint
- [ ] Logs authentication failures without logging the actual token value
- [ ] File compiles without errors
- [ ] File passes ktlint and detekt

**Tests**: Unit tests in Task 6.8 (`BearerTokenAuthTest.kt`).

#### Action 6.2.1: Create `BearerTokenAuth.kt`

**What**: Create the Ktor authentication middleware that validates bearer tokens on MCP routes.

**Context**: This is implemented as a Ktor `RouteScopedPlugin` (or intercept block) that runs before route handlers. The token is compared using `MessageDigest.isEqual()` which performs constant-time byte comparison, preventing timing side-channel attacks. The plugin is installed on the `/mcp` route group in `McpServer.kt` (Task 6.4). The `/health` endpoint is outside this route group and therefore not subject to authentication. The expected token is provided at construction time from `ServerConfig.bearerToken`.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/auth/BearerTokenAuth.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/auth/BearerTokenAuth.kt
@@ -0,0 +1,98 @@
+package com.danielealbano.androidremotecontrolmcp.mcp.auth
+
+import android.util.Log
+import io.ktor.http.HttpStatusCode
+import io.ktor.server.application.ApplicationCallPipeline
+import io.ktor.server.application.Hook
+import io.ktor.server.application.createRouteScopedPlugin
+import io.ktor.server.response.respond
+import kotlinx.serialization.Serializable
+import java.security.MessageDigest
+
+/**
+ * Response body returned for authentication failures.
+ */
+@Serializable
+data class AuthErrorResponse(
+    val error: String,
+    val message: String,
+)
+
+/**
+ * Configuration for the [BearerTokenAuthPlugin].
+ *
+ * @property expectedToken The bearer token that clients must present.
+ */
+class BearerTokenAuthConfig {
+    var expectedToken: String = ""
+}
+
+/**
+ * Ktor route-scoped plugin that validates Bearer token authentication.
+ *
+ * Install this plugin on route groups that require authentication (e.g., `/mcp`).
+ * Routes outside the installation scope (e.g., `/health`) are not affected.
+ *
+ * Uses [MessageDigest.isEqual] for constant-time token comparison to prevent
+ * timing side-channel attacks.
+ *
+ * Usage:
+ * ```kotlin
+ * route("/mcp") {
+ *     install(BearerTokenAuthPlugin) {
+ *         expectedToken = "my-secret-token"
+ *     }
+ *     // ... protected routes
+ * }
+ * ```
+ */
+val BearerTokenAuthPlugin = createRouteScopedPlugin(
+    name = "BearerTokenAuth",
+    createConfiguration = ::BearerTokenAuthConfig,
+) {
+    val expectedToken = pluginConfig.expectedToken
+
+    on(AuthenticationHook) { call ->
+        val authHeader = call.request.headers["Authorization"]
+
+        if (authHeader == null) {
+            Log.w(TAG, "Authentication failed: missing Authorization header from ${call.request.local.remoteAddress}")
+            call.respond(
+                HttpStatusCode.Unauthorized,
+                AuthErrorResponse(
+                    error = "unauthorized",
+                    message = "Missing Authorization header. Expected: Bearer <token>",
+                ),
+            )
+            return@on
+        }
+
+        if (!authHeader.startsWith(BEARER_PREFIX, ignoreCase = true)) {
+            Log.w(TAG, "Authentication failed: malformed Authorization header from ${call.request.local.remoteAddress}")
+            call.respond(
+                HttpStatusCode.Unauthorized,
+                AuthErrorResponse(
+                    error = "unauthorized",
+                    message = "Malformed Authorization header. Expected: Bearer <token>",
+                ),
+            )
+            return@on
+        }
+
+        // NOTE: see critical bug note below about case-sensitive removePrefix
+        val providedToken = authHeader.removePrefix(BEARER_PREFIX).trim()

> **CRITICAL — Case-sensitive bug**: `removePrefix(BEARER_PREFIX)` is case-sensitive but the `startsWith` check above is case-insensitive. If a client sends lowercase "bearer", the prefix won't be removed. Fix at implementation time: use `authHeader.substring(BEARER_PREFIX.length).trim()` instead of `removePrefix`.
+        val isValid = constantTimeEquals(expectedToken, providedToken)
+
+        if (!isValid) {
+            Log.w(TAG, "Authentication failed: invalid token from ${call.request.local.remoteAddress}")
+            call.respond(
+                HttpStatusCode.Unauthorized,
+                AuthErrorResponse(
+                    error = "unauthorized",
+                    message = "Invalid bearer token",
+                ),
+            )
+            return@on
+        }
+    }
+}
+
+private object AuthenticationHook : Hook<suspend (io.ktor.server.application.ApplicationCall) -> Unit> {
+    override fun install(pipeline: ApplicationCallPipeline, handler: suspend (io.ktor.server.application.ApplicationCall) -> Unit) {
+        pipeline.intercept(ApplicationCallPipeline.Plugins) {
+            handler(call)
+        }
+    }
+}
+
+internal fun constantTimeEquals(expected: String, provided: String): Boolean {
+    val expectedBytes = expected.toByteArray(Charsets.UTF_8)
+    val providedBytes = provided.toByteArray(Charsets.UTF_8)
+    return MessageDigest.isEqual(expectedBytes, providedBytes)
+}
+
+private const val TAG = "MCP:BearerTokenAuth"
+private const val BEARER_PREFIX = "Bearer "
```

> **Implementation Note on Ktor plugin approach**: The `createRouteScopedPlugin` API is used because authentication should only apply to the `/mcp/*` route group. At implementation time, verify that Ktor 3.x still supports `createRouteScopedPlugin`. If the API has changed, adapt to the current Ktor plugin system (e.g., `createApplicationPlugin` with route filtering, or use Ktor's built-in `Authentication` feature with a custom provider).

> **Implementation Note on `AuthenticationHook`**: The custom Hook intercepts at the `Plugins` phase of the pipeline, which runs before route handlers. This ensures authentication is checked before any tool execution. If Ktor's built-in `Authentication` plugin is more suitable (it has a `bearer` provider), consider using that instead. The custom approach is shown here for clarity and to ensure constant-time comparison is used.

> **Security Note**: The `constantTimeEquals` function is marked `internal` to allow unit testing from the test source set. The function uses `MessageDigest.isEqual()` which is guaranteed to be constant-time by the Java specification. Never use `==` or `equals()` for token comparison as they short-circuit on first mismatch, enabling timing attacks.

---

### Task 6.3: Create SSL Certificate Manager

**Description**: Create the `CertificateManager` class that handles self-signed certificate generation (RSA 2048-bit, X.509, 1-year validity) and custom certificate import (.p12/.pfx). Certificates are stored in app-private storage.

**Acceptance Criteria**:
- [ ] `getOrCreateKeyStore()` returns existing keystore or generates new self-signed certificate
- [ ] `generateSelfSignedCertificate()` creates RSA 2048-bit key pair with X.509 certificate
- [ ] Generated certificate has correct CN and SAN matching the provided hostname
- [ ] Generated certificate is valid for 1 year from creation
- [ ] Keystore is stored in `context.filesDir` as `mcp_keystore.p12`
- [ ] `importCustomCertificate()` loads `.p12`/`.pfx` bytes with the user-provided password
- [ ] `importCustomCertificate()` re-stores the keystore with the app's auto-generated password (so `loadCustomKeyStore()` can load it consistently)
- [ ] `importCustomCertificate()` rejects expired certificates
- [ ] `importCustomCertificate()` returns `Result.failure` for wrong password
- [ ] `getKeyStorePassword()` returns consistent password (generated once, stored)
- [ ] File compiles without errors
- [ ] File passes ktlint and detekt

**Tests**: Unit tests in Task 6.8 (`CertificateManagerTest.kt`).

#### Action 6.3.1: Create `CertificateManager.kt`

> **Implementation Note**: `CertificateManager.kt` is not listed in PROJECT.md's folder structure under `mcp/`. Update PROJECT.md to add it at implementation time.

**What**: Create the SSL certificate manager for HTTPS support.

**Context**: The MCP server defaults to HTTP, with HTTPS as an optional toggle. This class manages the KeyStore used by Ktor's SSL connector when HTTPS is enabled. On first launch, it generates a self-signed certificate using the standard Java security APIs. The hostname for CN and SAN comes from `ServerConfig.certificateHostname` (default: "android-mcp.local"). For self-signed certificate generation with SAN (Subject Alternative Names), the standard JDK APIs (`java.security.cert.X509Certificate`) do not directly support creating certificates. We use `sun.security.x509` internal APIs (available on Android) or Bouncy Castle. At implementation time, check if Bouncy Castle is needed as a dependency and add it to `libs.versions.toml` if so.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/CertificateManager.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/CertificateManager.kt
@@ -0,0 +1,199 @@
+package com.danielealbano.androidremotecontrolmcp.mcp
+
+import android.content.Context
+import android.util.Log
+import com.danielealbano.androidremotecontrolmcp.data.model.CertificateSource
+import com.danielealbano.androidremotecontrolmcp.data.model.ServerConfig
+import com.danielealbano.androidremotecontrolmcp.data.repository.SettingsRepository
+import dagger.hilt.android.qualifiers.ApplicationContext
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.runBlocking
+import java.io.File
+import java.io.FileInputStream
+import java.io.FileOutputStream
+import java.math.BigInteger
+import java.security.KeyPairGenerator
+import java.security.KeyStore
+import java.security.SecureRandom
+import java.security.cert.X509Certificate
+import java.util.Calendar
+import java.util.Date
+import javax.inject.Inject
+import javax.inject.Singleton
+import javax.security.auth.x500.X500Principal
+
+/**
+ * Manages SSL certificates for the MCP server when HTTPS is enabled.
+ *
+ * Supports two modes:
+ * - **Auto-generated**: Creates a self-signed RSA 2048-bit X.509 certificate
+ *   with CN and SAN matching the configured hostname. Valid for 1 year.
+ * - **Custom**: Imports a user-provided .p12/.pfx certificate file.
+ *
+ * Certificates are stored in app-private storage ([Context.getFilesDir]).
+ */
+@Singleton
+class CertificateManager @Inject constructor(
+    @ApplicationContext private val context: Context,
+    private val settingsRepository: SettingsRepository,
+) {
+
+    /**
+     * Returns the KeyStore for the server's HTTPS mode, loading an existing one
+     * or generating a new self-signed certificate if none exists.
+     *
+     * @return The [KeyStore] configured with the server certificate and private key.
+     */
+    fun getOrCreateKeyStore(): KeyStore {
+        val config = runBlocking { settingsRepository.serverConfig.first() }
+
+        return when (config.certificateSource) {
+            CertificateSource.AUTO_GENERATED -> getOrCreateAutoGeneratedKeyStore(config.certificateHostname)
+            CertificateSource.CUSTOM -> loadCustomKeyStore()
+                ?: getOrCreateAutoGeneratedKeyStore(config.certificateHostname)
+        }
+    }
+
+    /**
+     * Generates a new self-signed certificate with the given hostname.
+     *
+     * Overwrites any existing auto-generated keystore.
+     *
+     * @param hostname The hostname for the certificate CN and SAN.
+     * @return The [KeyStore] containing the new certificate.
+     */
+    fun generateSelfSignedCertificate(hostname: String): KeyStore {
+        Log.i(TAG, "Generating self-signed certificate for hostname: $hostname")
+
+        val keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM)
+        keyPairGenerator.initialize(KEY_SIZE, SecureRandom())
+        val keyPair = keyPairGenerator.generateKeyPair()
+
+        val notBefore = Date()
+        val calendar = Calendar.getInstance()
+        calendar.time = notBefore
+        calendar.add(Calendar.YEAR, CERTIFICATE_VALIDITY_YEARS)
+        val notAfter = calendar.time
+
+        val serialNumber = BigInteger(SERIAL_NUMBER_BIT_LENGTH, SecureRandom())
+        val subjectDN = X500Principal("CN=$hostname")
+
+        // Generate self-signed X.509 certificate using Bouncy Castle
+        val certBuilder = org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder(
+            subjectDN,
+            serialNumber,
+            notBefore,
+            notAfter,
+            subjectDN,
+            keyPair.public,
+        )
+
+        // Add Subject Alternative Name (SAN) extension for the hostname
+        val sanBuilder = org.bouncycastle.asn1.x509.GeneralNamesBuilder()
+        sanBuilder.addName(
+            org.bouncycastle.asn1.x509.GeneralName(
+                org.bouncycastle.asn1.x509.GeneralName.dNSName,
+                hostname,
+            ),
+        )
+        // Also add localhost and 127.0.0.1 as SANs for local development
+        sanBuilder.addName(
+            org.bouncycastle.asn1.x509.GeneralName(
+                org.bouncycastle.asn1.x509.GeneralName.dNSName,
+                "localhost",
+            ),
+        )
+        sanBuilder.addName(
+            org.bouncycastle.asn1.x509.GeneralName(
+                org.bouncycastle.asn1.x509.GeneralName.iPAddress,
+                "127.0.0.1",
+            ),
+        )
+        certBuilder.addExtension(
+            org.bouncycastle.asn1.x509.Extension.subjectAlternativeName,
+            false,
+            sanBuilder.build(),
+        )
+
+        // Sign the certificate with SHA256withRSA
+        val signer = org.bouncycastle.operator.jcajce.JcaContentSignerBuilder(SIGNATURE_ALGORITHM)
+            .build(keyPair.private)
+        val certHolder = certBuilder.build(signer)
+        val cert = org.bouncycastle.cert.jcajce.JcaX509CertificateConverter()
+            .setProvider(org.bouncycastle.jce.provider.BouncyCastleProvider())
+            .getCertificate(certHolder)
+
+        val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
+        keyStore.load(null, getKeyStorePassword())
+        keyStore.setKeyEntry(KEY_ALIAS, keyPair.private, getKeyStorePassword(), arrayOf(cert))
+
+        val keystoreFile = getAutoGeneratedKeystoreFile()
+        FileOutputStream(keystoreFile).use { fos ->
+            keyStore.store(fos, getKeyStorePassword())
+        }
+
+        Log.i(TAG, "Self-signed certificate generated and stored at: ${keystoreFile.absolutePath}")
+        return keyStore
+    }
+
+    /**
+     * Imports a custom .p12/.pfx certificate.
+     *
+     * @param certificateBytes The raw bytes of the .p12/.pfx file.
+     * @param password The password to decrypt the certificate file.
+     * @return [Result.success] with the [KeyStore] if import succeeds,
+     *         [Result.failure] with an appropriate exception if it fails.
+     */
+    fun importCustomCertificate(certificateBytes: ByteArray, password: String): Result<KeyStore> {
+        return try {
+            val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
+            keyStore.load(certificateBytes.inputStream(), password.toCharArray())
+
+            // Validate certificate is not expired
+            val aliases = keyStore.aliases()
+            while (aliases.hasMoreElements()) {
+                val alias = aliases.nextElement()
+                val cert = keyStore.getCertificate(alias)
+                if (cert is X509Certificate) {
+                    cert.checkValidity()
+                }
+            }
+
+            // Re-store the custom keystore with the app's auto-generated password.
+            // This ensures loadCustomKeyStore() can load it consistently using
+            // getKeyStorePassword(), regardless of the original import password.
+            val keystoreFile = getCustomKeystoreFile()
+            FileOutputStream(keystoreFile).use { fos ->
+                keyStore.store(fos, getKeyStorePassword())
+            }
+
+            Log.i(TAG, "Custom certificate imported successfully")
+            Result.success(keyStore)
+        } catch (e: java.security.cert.CertificateExpiredException) {
+            Log.w(TAG, "Custom certificate import failed: certificate expired", e)
+            Result.failure(IllegalArgumentException("Certificate is expired", e))
+        } catch (e: java.io.IOException) {
+            Log.w(TAG, "Custom certificate import failed: wrong password or invalid file", e)
+            Result.failure(IllegalArgumentException("Wrong password or invalid certificate file", e))
+        } catch (e: Exception) {
+            Log.e(TAG, "Custom certificate import failed", e)
+            Result.failure(e)
+        }
+    }
+
+    /**
+     * Returns the keystore password. Generates and persists one if none exists.
+     *
+     * The password is stored in a separate file in app-private storage.
+     */
+    fun getKeyStorePassword(): CharArray {
+        val passwordFile = File(context.filesDir, KEYSTORE_PASSWORD_FILENAME)
+        return if (passwordFile.exists()) {
+            passwordFile.readText().toCharArray()
+        } else {
+            val password = generatePassword()
+            passwordFile.writeText(String(password))
+            password
+        }
+    }
+
+    private fun getOrCreateAutoGeneratedKeyStore(hostname: String): KeyStore {
+        val keystoreFile = getAutoGeneratedKeystoreFile()
+        return if (keystoreFile.exists()) {
+            val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
+            FileInputStream(keystoreFile).use { fis ->
+                keyStore.load(fis, getKeyStorePassword())
+            }
+            keyStore
+        } else {
+            generateSelfSignedCertificate(hostname)
+        }
+    }
+
+    private fun loadCustomKeyStore(): KeyStore? {
+        val keystoreFile = getCustomKeystoreFile()
+        if (!keystoreFile.exists()) return null
+
+        return try {
+            val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
+            FileInputStream(keystoreFile).use { fis ->
+                keyStore.load(fis, getKeyStorePassword())
+            }
+            keyStore
+        } catch (e: Exception) {
+            Log.e(TAG, "Failed to load custom keystore, falling back to auto-generated", e)
+            null
+        }
+    }
+
+    private fun getAutoGeneratedKeystoreFile(): File = File(context.filesDir, KEYSTORE_FILENAME)
+
+    private fun getCustomKeystoreFile(): File = File(context.filesDir, CUSTOM_KEYSTORE_FILENAME)
+
+    private fun generatePassword(): CharArray {
+        val bytes = ByteArray(PASSWORD_LENGTH)
+        SecureRandom().nextBytes(bytes)
+        return bytes.joinToString("") { "%02x".format(it) }.toCharArray()
+    }
+
+    companion object {
+        private const val TAG = "MCP:CertificateManager"
+        const val KEY_ALIAS = "mcp-server"
+        const val KEYSTORE_FILENAME = "mcp_keystore.p12"
+        const val CUSTOM_KEYSTORE_FILENAME = "mcp_custom_keystore.p12"
+        const val KEYSTORE_PASSWORD_FILENAME = "mcp_keystore_password"
+        const val KEYSTORE_TYPE = "PKCS12"
+        const val KEY_ALGORITHM = "RSA"
+        const val KEY_SIZE = 2048
+        const val SIGNATURE_ALGORITHM = "SHA256withRSA"
+        const val CERTIFICATE_VALIDITY_YEARS = 1
+        const val SERIAL_NUMBER_BIT_LENGTH = 128
+        const val PASSWORD_LENGTH = 32
+    }
+}
```

> **Implementation Note on certificate generation**: The `generateSelfSignedCertificate()` method uses **Bouncy Castle** (`org.bouncycastle:bcpkix-jdk18on` and `org.bouncycastle:bcprov-jdk18on`) for X.509 certificate generation with SAN (Subject Alternative Name) support. Bouncy Castle MUST be added to `libs.versions.toml` and `app/build.gradle.kts` (see Task 6.7). The generated certificate includes SANs for the configured hostname, `localhost`, and `127.0.0.1` to support local development scenarios. At implementation time, verify the latest Bouncy Castle version (currently `1.78.1` as of this plan).

> **Security Note on keystore password**: The keystore password is stored as plaintext in app-private storage (`context.filesDir`). This is acceptable because the files directory is sandboxed by Android's application sandbox. Only the app (or root) can access it. For additional security, consider using Android Keystore system or EncryptedFile from AndroidX Security library, but this is not required for the current scope.

---

### Task 6.4: Create Ktor MCP Server

**Description**: Create the `McpServer` class that configures and runs the Ktor Netty embedded server with HTTP (and optional HTTPS), content negotiation, routing, bearer token authentication, and status pages for error handling.

**Acceptance Criteria**:
- [ ] `McpServer` starts Ktor Netty server with HTTP by default, and optionally with HTTPS when enabled in settings
- [ ] SSL configured using KeyStore from `CertificateManager`
- [ ] ContentNegotiation installed with kotlinx.serialization JSON
- [ ] Routing installed with `/health`, `/mcp/v1/initialize`, `/mcp/v1/tools/list`, `/mcp/v1/tools/call`
- [ ] `BearerTokenAuthPlugin` installed on `/mcp` route group only
- [ ] `/health` endpoint returns JSON `{"status":"healthy","version":"...","server":"running"}` with HTTP 200
- [ ] `/health` endpoint is NOT authenticated
- [ ] StatusPages installed for general error handling (500 Internal Server Error as JSON)
- [ ] `start()`, `stop()`, `isRunning()` methods work correctly
- [ ] `stop()` waits for in-flight requests with configurable timeout
- [ ] File compiles without errors
- [ ] File passes ktlint and detekt

**Tests**: `McpServer` is tested indirectly via `McpProtocolHandlerTest` (protocol logic) and integration tests. Direct unit testing of Ktor server startup would require a Ktor test engine, which is deferred to integration tests.

#### Action 6.4.1: Create `McpServer.kt`

**What**: Create the Ktor embedded server (HTTP by default, optional HTTPS) with routing, authentication, and MCP protocol handling.

**Context**: This class wraps the Ktor `embeddedServer` call. It is created and managed by `McpServerService` (Task 6.5). The server defaults to HTTP, with optional HTTPS via Ktor's `sslConnector` when enabled in settings. The `McpProtocolHandler` is injected and handles all JSON-RPC protocol logic. The `BearerTokenAuthPlugin` is installed on the `/mcp` route group, leaving `/health` unauthenticated. The health endpoint returns the app version from `BuildConfig.VERSION_NAME`. Content negotiation uses kotlinx.serialization JSON for automatic request/response serialization.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpServer.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpServer.kt
@@ -0,0 +1,172 @@
+package com.danielealbano.androidremotecontrolmcp.mcp
+
+import android.util.Log
+import com.danielealbano.androidremotecontrolmcp.BuildConfig
+import com.danielealbano.androidremotecontrolmcp.data.model.ServerConfig
+import com.danielealbano.androidremotecontrolmcp.mcp.auth.BearerTokenAuthPlugin
+import io.ktor.http.ContentType
+import io.ktor.http.HttpStatusCode
+import io.ktor.serialization.kotlinx.json.json
+import io.ktor.server.application.install
+import io.ktor.server.engine.EmbeddedServer
+import io.ktor.server.engine.embeddedServer
+import io.ktor.server.engine.sslConnector
+import io.ktor.server.netty.Netty
+import io.ktor.server.netty.NettyApplicationEngine
+import io.ktor.server.plugins.contentnegotiation.ContentNegotiation
+import io.ktor.server.plugins.statuspages.StatusPages
+import io.ktor.server.request.receive
+import io.ktor.server.response.respond
+import io.ktor.server.response.respondText
+import io.ktor.server.routing.get
+import io.ktor.server.routing.post
+import io.ktor.server.routing.route
+import io.ktor.server.routing.routing
+import kotlinx.serialization.json.Json
+import kotlinx.serialization.json.buildJsonObject
+import kotlinx.serialization.json.put
+import java.security.KeyStore
+import java.util.concurrent.atomic.AtomicBoolean
+
+/**
+ * Ktor-based MCP server (HTTP by default, optional HTTPS).
+ *
+ * Configures and runs an embedded Netty server with:
+ * - HTTP by default, optional HTTPS when enabled in settings
+ * - JSON content negotiation (kotlinx.serialization)
+ * - Bearer token authentication on /mcp/* routes
+ * - Health check endpoint (unauthenticated)
+ * - MCP JSON-RPC 2.0 protocol routes
+ * - Status pages for error handling
+ *
+ * @param config The server configuration (port, binding address, bearer token).
+ * @param keyStore The SSL KeyStore for HTTPS.
+ * @param keyStorePassword The KeyStore password.
+ * @param protocolHandler The MCP protocol handler for JSON-RPC processing.
+ */
+class McpServer(
+    private val config: ServerConfig,
+    private val keyStore: KeyStore,
+    private val keyStorePassword: CharArray,
+    private val protocolHandler: McpProtocolHandler,
+) {
+
+    private var server: EmbeddedServer<NettyApplicationEngine, NettyApplicationEngine.Configuration>? = null
+    private val running = AtomicBoolean(false)
+
+    /**
+     * Starts the server. Non-blocking — the server runs on its own threads.
+     */
+    fun start() {
+        if (running.get()) {
+            Log.w(TAG, "Server is already running, ignoring start request")
+            return
+        }
+
+        Log.i(TAG, "Starting MCP server on ${config.bindingAddress.address}:${config.port}")
+
> **CRITICAL — No plain HTTP connector**: The `start()` method ONLY configures `sslConnector(...)`. There is NO `connector(...)` call for plain HTTP. Since HTTPS is optional and disabled by default (PROJECT.md line 485), at implementation time: add a conditional check — if HTTPS is enabled in config, use `sslConnector(...)`, otherwise use `connector { port = config.port; host = config.bindingAddress.address }` for plain HTTP. The `ServerConfig.httpsEnabled` field (see Plan 2 NC1 note) controls this toggle.

+        server = embeddedServer(
+            factory = Netty,
+            configure = {
+                sslConnector(
+                    keyStore = keyStore,
+                    keyAlias = CertificateManager.KEY_ALIAS,
+                    keyStorePassword = { keyStorePassword },
+                    privateKeyPassword = { keyStorePassword },
+                ) {
+                    host = config.bindingAddress.address
+                    port = config.port
+                }
+            },
+        ) {
+            install(ContentNegotiation) {
+                json(Json {
+                    prettyPrint = false
+                    isLenient = false
+                    ignoreUnknownKeys = true
+                    encodeDefaults = true
+                })
+            }
+
+            install(StatusPages) {
+                exception<Throwable> { call, cause ->
+                    Log.e(TAG, "Unhandled exception in request handler", cause)
+                    call.respond(
+                        HttpStatusCode.InternalServerError,
+                        buildJsonObject {
+                            put("error", "internal_server_error")
+                            put("message", cause.message ?: "Unknown error")
+                        },
+                    )
+                }
+            }
+
+            routing {
+                // Health endpoint — unauthenticated
+                get("/health") {
+                    call.respondText(
+                        contentType = ContentType.Application.Json,
+                        text = Json.encodeToString(
+                            kotlinx.serialization.json.JsonObject.serializer(),
+                            buildJsonObject {
+                                put("status", "healthy")
+                                put("version", BuildConfig.VERSION_NAME)
+                                put("server", "running")
+                            },
+                        ),
+                    )
+                }
+
+                // MCP routes — authenticated
+                route("/mcp") {
+                    install(BearerTokenAuthPlugin) {
+                        expectedToken = config.bearerToken
+                    }
+
+                    route("/v1") {
+                        post("/initialize") {
+                            val request = call.receive<JsonRpcRequest>()
+                            val response = protocolHandler.handleRequest(request)
+                            call.respond(response)
+                        }
+
+                        get("/tools/list") {
+                            // For GET requests, there is no JSON-RPC body to extract an ID from.
+                            // Use the "id" query parameter if provided, otherwise use null.
+                            // This ensures clients can track responses even for GET endpoints.
+                            val idParam = call.request.queryParameters["id"]
+                            val requestId: kotlinx.serialization.json.JsonElement? = idParam?.let {
+                                kotlinx.serialization.json.JsonPrimitive(it)
+                            }
+                            val request = JsonRpcRequest(
+                                method = McpProtocolHandler.METHOD_TOOLS_LIST,
+                                id = requestId,
+                            )
+                            val response = protocolHandler.handleRequest(request)
+                            call.respond(response)
+                        }
+
+                        post("/tools/call") {
+                            val request = call.receive<JsonRpcRequest>()
+                            val response = protocolHandler.handleRequest(request)
+                            call.respond(response)
+                        }
+                    }
+                }
+            }
+        }
+
+        server?.start(wait = false)
+        running.set(true)
+        Log.i(TAG, "MCP server started successfully")
+    }
+
+    /**
+     * Stops the server gracefully, waiting for in-flight requests.
+     *
+     * @param gracePeriodMillis Grace period before force-stopping connections.
+     * @param timeoutMillis Maximum time to wait for shutdown.
+     */
+    fun stop(gracePeriodMillis: Long = DEFAULT_GRACE_PERIOD_MS, timeoutMillis: Long = DEFAULT_TIMEOUT_MS) {
+        if (!running.get()) {
+            Log.w(TAG, "Server is not running, ignoring stop request")
+            return
+        }
+
+        Log.i(TAG, "Stopping MCP server (grace=${gracePeriodMillis}ms, timeout=${timeoutMillis}ms)")
+        server?.stop(gracePeriodMillis, timeoutMillis)
+        server = null
+        running.set(false)
+        Log.i(TAG, "MCP server stopped")
+    }
+
+    fun isRunning(): Boolean = running.get()
+
+    companion object {
+        private const val TAG = "MCP:McpServer"
+        private const val DEFAULT_GRACE_PERIOD_MS = 1000L
+        private const val DEFAULT_TIMEOUT_MS = 5000L
+    }
+}
```

> **Implementation Note on Ktor `sslConnector`**: The `sslConnector` configuration shown above uses Ktor 3.x APIs. At implementation time, verify the exact API shape. In Ktor 3.x, the `embeddedServer` with Netty may use `applicationEnvironment` and `serverConfig` builders instead of the older lambda style. Adapt the code to match the actual Ktor 3.x API available.

> **Implementation Note on `tools/list` as GET**: The `tools/list` endpoint is mapped as `GET` per PROJECT.md. Since GET requests have no body, we construct a synthetic `JsonRpcRequest` for the protocol handler. The `id` for the JSON-RPC response is taken from the `?id=` query parameter if provided, otherwise it is `null`. This ensures the response correctly echoes the client's request ID per the JSON-RPC 2.0 specification (all responses MUST include the same `id` as the request). At implementation time, verify whether the MCP specification requires this as a POST with a JSON-RPC body. If so, change to POST and use `call.receive<JsonRpcRequest>()` which naturally extracts the `id`.

> **Performance Note**: The Ktor Netty server uses NIO and is non-blocking. It handles multiple concurrent MCP requests efficiently. The `protocolHandler.handleRequest()` is a suspending function, allowing coroutine-based concurrency for tool execution.

---

### Task 6.5: Create McpServerService and BootCompletedReceiver

**Description**: Create the `McpServerService` foreground service that manages the MCP server lifecycle, and the `BootCompletedReceiver` that auto-starts the service on device boot if enabled in settings.

**Acceptance Criteria**:
- [ ] `McpServerService` extends `Service()` and is annotated `@AndroidEntryPoint`
- [ ] `onStartCommand()` calls `startForeground()` with notification on `mcp_server_channel`
- [ ] `onStartCommand()` stores singleton instance, reads config, binds to ScreenCaptureService, starts McpServer
- [ ] `onStartCommand()` updates `ServerStatus.Running` via companion-level `MutableStateFlow`
- [ ] `onDestroy()` stops McpServer gracefully (5s timeout), unbinds ScreenCaptureService, clears singleton
- [ ] `onDestroy()` updates `ServerStatus.Stopped` via companion-level `MutableStateFlow`
- [ ] `onBind()` returns null (started service, not bound)
- [ ] Companion object has `instance`, `ACTION_START`, `ACTION_STOP`, `serverStatus: StateFlow<ServerStatus>`
- [ ] `BootCompletedReceiver` checks auto-start setting and starts service if enabled
- [ ] Files compile without errors
- [ ] Files pass ktlint and detekt

**Tests**: Service lifecycle is tested via integration tests (deferred). Unit tests for `BootCompletedReceiver` logic would require mocking Android Context heavily; covered by integration tests.

#### Action 6.5.1: Create `McpServerService.kt`

**What**: Create the foreground service that manages the MCP server.

**Context**: This is a started service (not bound) controlled via `startService()` / `stopService()` intents from the UI. It uses `@AndroidEntryPoint` for Hilt injection of `SettingsRepository`, `McpProtocolHandler`, and `CertificateManager`. The service creates a `McpServer` instance and manages its lifecycle. It binds to `ScreenCaptureService` to provide screenshot capabilities to MCP tools. Status updates are published via a companion-level `MutableStateFlow<ServerStatus>` and collected by `MainViewModel` (Task 6.6). This replaces the deprecated `LocalBroadcastManager` with a more Kotlin-idiomatic approach.

**IMPORTANT - ScreenCaptureService startup sequence**: When binding to `ScreenCaptureService`, the service MUST first call `startForegroundService()` and THEN `bindService()`. Using `bindService()` alone does NOT trigger `onStartCommand()`, meaning `startForeground()` would never be called, violating the Android 5-second foreground service requirement.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/McpServerService.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/McpServerService.kt
@@ -0,0 +1,188 @@
+package com.danielealbano.androidremotecontrolmcp.services.mcp
+
+import android.app.Notification
+import android.app.PendingIntent
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.Intent
+import android.content.ServiceConnection
+import android.os.IBinder
+import android.util.Log
+import androidx.core.app.NotificationCompat
+import com.danielealbano.androidremotecontrolmcp.R
+import com.danielealbano.androidremotecontrolmcp.data.model.ServerConfig
+import com.danielealbano.androidremotecontrolmcp.data.model.ServerStatus
+import com.danielealbano.androidremotecontrolmcp.data.repository.SettingsRepository
+import com.danielealbano.androidremotecontrolmcp.mcp.CertificateManager
+import com.danielealbano.androidremotecontrolmcp.mcp.McpProtocolHandler
+import com.danielealbano.androidremotecontrolmcp.mcp.McpServer
+import com.danielealbano.androidremotecontrolmcp.services.screencapture.ScreenCaptureService
+import com.danielealbano.androidremotecontrolmcp.ui.MainActivity
+import dagger.hilt.android.AndroidEntryPoint
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.SupervisorJob
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+
+/**
+ * Foreground service that runs the MCP server (HTTP by default, optional HTTPS).
+ *
+ * Lifecycle:
+ * 1. Started via intent from MainActivity (start/stop button)
+ * 2. Calls startForeground() with persistent notification
+ * 3. Reads configuration from SettingsRepository
+ * 4. Binds to ScreenCaptureService for screenshot support
+ * 5. Creates and starts McpServer (Ktor HTTP, optionally HTTPS)
+ * 6. Updates ServerStatus via companion-level StateFlow (collected by MainViewModel)
+ * 7. On stop: gracefully shuts down server, unbinds services, clears singleton
+ */
+@AndroidEntryPoint
+class McpServerService : Service() {
+
+    @Inject lateinit var settingsRepository: SettingsRepository
+    @Inject lateinit var protocolHandler: McpProtocolHandler
+    @Inject lateinit var certificateManager: CertificateManager
+
+    private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
+    private var mcpServer: McpServer? = null
+    private var screenCaptureService: ScreenCaptureService? = null
+    private var isBoundToScreenCapture = false
+
+    private val screenCaptureConnection = object : ServiceConnection {
+        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
+            val localBinder = binder as? ScreenCaptureService.LocalBinder
+            screenCaptureService = localBinder?.getService()
+            Log.i(TAG, "Bound to ScreenCaptureService")
+        }
+
+        override fun onServiceDisconnected(name: ComponentName?) {
+            screenCaptureService = null
+            Log.i(TAG, "Disconnected from ScreenCaptureService")
+        }
+    }
+
+    override fun onCreate() {
+        super.onCreate()
+        instance = this
+        Log.i(TAG, "McpServerService created")
+    }
+
+    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
+        startForeground(NOTIFICATION_ID, createNotification())
+
+        when (intent?.action) {
+            ACTION_STOP -> {
+                stopSelf()
+                return START_NOT_STICKY
+            }
+            ACTION_START, null -> {
+                coroutineScope.launch {
+                    startServer()
+                }
+            }
+        }
+
+        return START_STICKY
+    }
+
+    private suspend fun startServer() {
+        try {
+            updateStatus(ServerStatus.Starting)
+
+            val config = settingsRepository.serverConfig.first()
+            Log.i(TAG, "Starting MCP server with config: port=${config.port}, binding=${config.bindingAddress.address}")
+
+            // Bind to ScreenCaptureService
+            bindToScreenCaptureService()
+
> **CRITICAL — Unconditional certificate generation**: `startServer()` always calls `certificateManager.getOrCreateKeyStore()` regardless of whether HTTPS is enabled. At implementation time, wrap the certificate manager calls in `if (config.httpsEnabled)` to avoid unnecessary self-signed certificate generation when HTTPS is disabled (the default).

+            // Get or create SSL keystore
+            val keyStore = certificateManager.getOrCreateKeyStore()
+            val keyStorePassword = certificateManager.getKeyStorePassword()
+
+            // Create and start the Ktor server
+            mcpServer = McpServer(
+                config = config,
+                keyStore = keyStore,
+                keyStorePassword = keyStorePassword,
+                protocolHandler = protocolHandler,
+            )
+            mcpServer?.start()
+
+            updateStatus(
+                ServerStatus.Running(
+                    port = config.port,
+                    bindingAddress = config.bindingAddress.address,
+                ),
+            )
+
+            Log.i(TAG, "MCP server started successfully on ${config.bindingAddress.address}:${config.port}")
+        } catch (e: Exception) {
+            Log.e(TAG, "Failed to start MCP server", e)
+            updateStatus(ServerStatus.Error(e.message ?: "Unknown error starting server"))
+        }
+    }
+
+    override fun onDestroy() {
+        Log.i(TAG, "McpServerService destroying")
+        updateStatus(ServerStatus.Stopping)
+
+        // Stop the Ktor server gracefully
+        try {
+            mcpServer?.stop(
+                gracePeriodMillis = SHUTDOWN_GRACE_PERIOD_MS,
+                timeoutMillis = SHUTDOWN_TIMEOUT_MS,
+            )
+        } catch (e: Exception) {
+            Log.e(TAG, "Error during server shutdown", e)
+        }
+        mcpServer = null
+
+        // Unbind from ScreenCaptureService
+        if (isBoundToScreenCapture) {
+            try {
+                unbindService(screenCaptureConnection)
+            } catch (e: Exception) {
+                Log.e(TAG, "Error unbinding from ScreenCaptureService", e)
+            }
+            isBoundToScreenCapture = false
+        }
+        screenCaptureService = null
+
+        // Cancel coroutine scope
+        coroutineScope.cancel()
+
+        // Clear singleton
+        instance = null
+
+        updateStatus(ServerStatus.Stopped)
+        Log.i(TAG, "McpServerService destroyed")
+
+        super.onDestroy()
+    }
+
+    override fun onBind(intent: Intent?): IBinder? = null
+
+    private fun bindToScreenCaptureService() {
+        val intent = Intent(this, ScreenCaptureService::class.java)
+        // MUST start as foreground service first, THEN bind.
+        // bindService() alone does NOT trigger onStartCommand(), so startForeground()
+        // would never be called, violating the 5-second foreground service requirement.
+        startForegroundService(intent)
+        isBoundToScreenCapture = bindService(intent, screenCaptureConnection, Context.BIND_AUTO_CREATE)
+        Log.d(TAG, "Started and binding to ScreenCaptureService: $isBoundToScreenCapture")
+    }
+
+    private fun updateStatus(status: ServerStatus) {
+        _serverStatus.value = status
+    }
+
+    private fun createNotification(): Notification {
+        val pendingIntent = PendingIntent.getActivity(
+            this,
+            0,
+            Intent(this, MainActivity::class.java),
+            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT,
+        )
+
+        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
+            .setContentTitle(getString(R.string.notification_mcp_server_title))
+            .setSmallIcon(R.drawable.ic_notification)
+            .setContentIntent(pendingIntent)
+            .setOngoing(true)
+            .build()

> **Implementation Note — Notification API inconsistency**: `McpServerService` uses `NotificationCompat.Builder` (AndroidX) while `ScreenCaptureService` (Plan 5) uses `Notification.Builder` (Android framework). At implementation time, standardize on `NotificationCompat.Builder` across both services for consistency and backward compatibility.
+    }
+
+    companion object {
+        private const val TAG = "MCP:ServerService"
+        const val ACTION_START = "com.danielealbano.androidremotecontrolmcp.ACTION_START_MCP_SERVER"
+        const val ACTION_STOP = "com.danielealbano.androidremotecontrolmcp.ACTION_STOP_MCP_SERVER"
+        const val NOTIFICATION_CHANNEL_ID = "mcp_server_channel"
+        const val NOTIFICATION_ID = 1001
+        const val SHUTDOWN_GRACE_PERIOD_MS = 1000L
+        const val SHUTDOWN_TIMEOUT_MS = 5000L
+
+        /**
+         * Shared server status flow. Collected by MainViewModel to update the UI.
+         * Uses a companion-level StateFlow so it survives service rebinding and is
+         * accessible without requiring a bound service reference.
+         */
+        private val _serverStatus = MutableStateFlow<ServerStatus>(ServerStatus.Stopped)
+        val serverStatus: StateFlow<ServerStatus> = _serverStatus.asStateFlow()
+
+        @Volatile
+        var instance: McpServerService? = null
+            private set
+    }
+}
```

> **Implementation Note on `@AndroidEntryPoint`**: Hilt's `@AndroidEntryPoint` annotation supports `Service` subclasses. The injected fields (`settingsRepository`, `protocolHandler`, `certificateManager`) are available after `onCreate()` is called. The `onStartCommand()` method launches a coroutine to perform async initialization (reading config, creating keystore) without blocking the main thread.

> **Implementation Note on `ScreenCaptureService` binding**: The `ScreenCaptureService` is assumed to have a `LocalBinder` inner class that provides `getService()` returning the service instance (standard bound service pattern from Plan 5). If Plan 5 uses a different binding pattern, adjust the `ServiceConnection` implementation accordingly.

> **Implementation Note on status communication**: `LocalBroadcastManager` is deprecated and is NOT used. Instead, server status is published via a companion-level `MutableStateFlow<ServerStatus>` in `McpServerService.Companion`. The `MainViewModel` collects this flow in its `init{}` block using `viewModelScope`. This approach is more Kotlin-idiomatic, avoids a deprecated dependency, and ensures status updates are received regardless of Activity lifecycle state.

---

#### Action 6.5.2: Create `BootCompletedReceiver.kt`

**What**: Create the broadcast receiver that auto-starts the MCP server on device boot.

**Context**: Registered in `AndroidManifest.xml` (Plan 1) with `BOOT_COMPLETED` intent filter. When the device boots, Android delivers the `BOOT_COMPLETED` broadcast. The receiver checks if auto-start is enabled in settings and starts `McpServerService` if so. The `RECEIVE_BOOT_COMPLETED` permission is already declared in the manifest. Uses `goAsync()` to get a `PendingResult` that allows running a coroutine to read settings from DataStore.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/BootCompletedReceiver.kt`

```diff
--- /dev/null
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/BootCompletedReceiver.kt
@@ -0,0 +1,55 @@
+package com.danielealbano.androidremotecontrolmcp.services.mcp
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.util.Log
+import com.danielealbano.androidremotecontrolmcp.data.repository.SettingsRepository
+import dagger.hilt.android.AndroidEntryPoint
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+
+/**
+ * Receives BOOT_COMPLETED broadcast and auto-starts the MCP server
+ * if the auto-start setting is enabled.
+ *
+ * Uses [goAsync] to extend the broadcast receiver's lifecycle beyond the
+ * default 10-second limit, allowing a coroutine to read settings from DataStore.
+ */
+@AndroidEntryPoint
+class BootCompletedReceiver : BroadcastReceiver() {
+
+    @Inject lateinit var settingsRepository: SettingsRepository
+
+    override fun onReceive(context: Context, intent: Intent) {
+        if (intent.action != Intent.ACTION_BOOT_COMPLETED) {
+            return
+        }
+
+        Log.i(TAG, "Boot completed broadcast received")
+
+        val pendingResult = goAsync()
+        // See implementation note below about SupervisorJob
+        CoroutineScope(Dispatchers.IO).launch {

> **Implementation Note**: The `CoroutineScope(Dispatchers.IO)` lacks a `SupervisorJob()`. Consider using `CoroutineScope(SupervisorJob() + Dispatchers.IO)` for consistency with other services.
+            try {
+                val config = settingsRepository.serverConfig.first()
+
+                if (config.autoStartOnBoot) {
+                    Log.i(TAG, "Auto-start enabled, starting McpServerService")
+                    val serviceIntent = Intent(context, McpServerService::class.java).apply {
+                        action = McpServerService.ACTION_START
+                    }
+                    context.startForegroundService(serviceIntent)
+                } else {
+                    Log.i(TAG, "Auto-start disabled, skipping MCP server start")
+                }
+            } catch (e: Exception) {
+                Log.e(TAG, "Error checking auto-start setting on boot", e)
+            } finally {
+                pendingResult.finish()
+            }
+        }
+    }
+
+    companion object {
+        private const val TAG = "MCP:BootReceiver"
+    }
+}
```

> **Implementation Note on `@AndroidEntryPoint` for BroadcastReceiver**: Hilt supports `@AndroidEntryPoint` on `BroadcastReceiver`. This allows `@Inject` fields. At implementation time, verify that Hilt's BroadcastReceiver support is available in the version used. If not, manually access the Hilt `EntryPoint` interface pattern instead.

> **Implementation Note on `startForegroundService`**: On Android 8.0+ (API 26+, which is our minSdk), `startForegroundService()` must be used instead of `startService()` for foreground services. The service MUST call `startForeground()` within 5 seconds or the system will stop it and report an ANR.

---

### Task 6.6: Wire Server Lifecycle to UI

**Description**: Update `MainViewModel`, `MainActivity`, and `McpApplication` to wire the MCP server service to the UI. Replace stub `startServer()`/`stopServer()` with real service intents, add broadcast receiver for status updates, and create notification channels.

**Acceptance Criteria**:
- [ ] `MainViewModel.startServer()` sends `ACTION_START` intent to `McpServerService` via `startForegroundService()`
- [ ] `MainViewModel.stopServer()` sends `ACTION_STOP` intent to `McpServerService`
- [ ] `MainViewModel` collects `McpServerService.serverStatus` StateFlow in `init{}` block to observe server status changes (replaces deprecated `LocalBroadcastManager`)
- [ ] `MainActivity` calls `viewModel.refreshPermissionStatus(this)` in `onResume()` (no broadcast receiver registration needed)
- [ ] `McpApplication.onCreate()` creates `mcp_server_channel` and `screen_capture_channel` notification channels
- [ ] All files compile without errors
- [ ] All files pass ktlint and detekt

**Tests**: ViewModel logic tested in existing `MainViewModelTest` (update to cover new methods). Integration test coverage in existing `MainActivityTest`.

#### Action 6.6.1: Update `MainViewModel.kt`

**What**: Replace stub `startServer()`/`stopServer()` methods with real service intents and add broadcast receiver for server status updates.

**Context**: The existing `MainViewModel` (from Plan 3) has stub `startServer()` and `stopServer()` methods that only log a message. This action replaces them with real implementations that send intents to `McpServerService`. Instead of the deprecated `LocalBroadcastManager`, the ViewModel collects the `McpServerService.serverStatus` companion-level `StateFlow` to observe server status changes. This is more Kotlin-idiomatic and avoids a deprecated dependency.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/viewmodels/MainViewModel.kt`

Changes to apply (diff against Plan 3 version):

```diff
--- a/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/viewmodels/MainViewModel.kt
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/viewmodels/MainViewModel.kt
@@ imports section - add these imports:
+import android.content.Intent
+import com.danielealbano.androidremotecontrolmcp.services.mcp.McpServerService

@@ replace startServer() method:
-    fun startServer() {
-        Log.i(TAG, "startServer called (stub, will be wired in Plan 6)")
-    }
+    fun startServer(context: Context) {
+        Log.i(TAG, "Starting MCP server via McpServerService")
+        _serverStatus.value = ServerStatus.Starting
+        val intent = Intent(context, McpServerService::class.java).apply {
+            action = McpServerService.ACTION_START
+        }
+        context.startForegroundService(intent)
+    }

> **Implementation Note — Breaking change**: This changes the `startServer()`/`stopServer()` signatures to require a `Context` parameter. All call sites in `HomeScreen.kt` (from Plan 3) must be updated to pass the context. The HomeScreen update diff is not included in this plan — apply it at implementation time.

@@ replace stopServer() method:
-    fun stopServer() {
-        Log.i(TAG, "stopServer called (stub, will be wired in Plan 6)")
-    }
+    fun stopServer(context: Context) {
+        Log.i(TAG, "Stopping MCP server via McpServerService")
+        _serverStatus.value = ServerStatus.Stopping
+        val intent = Intent(context, McpServerService::class.java).apply {
+            action = McpServerService.ACTION_STOP
+        }
+        context.startForegroundService(intent)
+    }

@@ add in init{} block or constructor - collect server status from McpServerService:
+    init {
+        // Collect server status from McpServerService's companion-level StateFlow.
+        // This replaces the deprecated LocalBroadcastManager approach with a
+        // Kotlin-idiomatic StateFlow collection pattern.
+        viewModelScope.launch {
+            McpServerService.serverStatus.collect { status ->
+                _serverStatus.value = status
+            }
+        }
+    }
```

> **Implementation Note**: The `startServer()` and `stopServer()` methods now take a `Context` parameter. All call sites in `HomeScreen.kt` (from Plan 3) must be updated to pass the context. Use `LocalContext.current` in Compose to obtain the context.

> **Implementation Note on StateFlow approach**: Instead of the deprecated `LocalBroadcastManager`, the ViewModel collects `McpServerService.serverStatus` (a companion-level `StateFlow<ServerStatus>`) in its `init{}` block using `viewModelScope.launch`. This is more Kotlin-idiomatic, avoids a deprecated dependency, and eliminates the need for `registerStatusReceiver`/`unregisterStatusReceiver` in `MainActivity`'s lifecycle methods.

---

#### Action 6.6.2: Update `MainActivity.kt`

**What**: Add lifecycle callbacks for permission refresh.

**Context**: The existing `MainActivity` (from Plan 3) sets up the Compose UI with `HomeScreen`. Since server status is now observed via `StateFlow` (collected in `MainViewModel.init{}`), there is no need for `registerStatusReceiver`/`unregisterStatusReceiver`. This action adds `onResume()` only for refreshing permission status when the user returns from Settings.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/MainActivity.kt`

Changes to apply (diff against Plan 3 version):

```diff
--- a/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/MainActivity.kt
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/MainActivity.kt
@@ add to imports:
+import androidx.activity.viewModels
+import com.danielealbano.androidremotecontrolmcp.ui.viewmodels.MainViewModel

@@ add field in class body (before or after onCreate):
+    private val viewModel: MainViewModel by viewModels()

@@ add onResume() method:
+    override fun onResume() {
+        super.onResume()
+        viewModel.refreshPermissionStatus(this)
+    }
+    // NOTE: No onPause() needed for broadcast receiver since we use StateFlow
+    // for server status, which is collected in MainViewModel via viewModelScope.
```

> **Implementation Note**: The `by viewModels()` delegation requires `activity-ktx` dependency. Verify it is included in dependencies. We need the ViewModel reference in `onResume()` for permission refresh. Since server status is observed via `StateFlow` (collected in `MainViewModel.init{}`), there is no `onPause()` cleanup needed for broadcast receivers.

---

#### Action 6.6.3: Update `McpApplication.kt`

**What**: Add notification channel creation in `McpApplication.onCreate()`.

**Context**: Android 8.0+ (API 26+) requires notification channels to be created before showing notifications. Foreground services need a notification, so the channels must be created at application startup. Two channels are needed: one for the MCP server service and one for the screen capture service.

**File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/McpApplication.kt`

Changes to apply (diff against Plan 1 version):

```diff
--- a/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/McpApplication.kt
+++ b/app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/McpApplication.kt
@@ -1,12 +1,43 @@
 package com.danielealbano.androidremotecontrolmcp

 import android.app.Application
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.util.Log
 import dagger.hilt.android.HiltAndroidApp

 @HiltAndroidApp
 class McpApplication : Application() {

+    override fun onCreate() {
+        super.onCreate()
+        createNotificationChannels()
+        Log.i(TAG, "Application initialized, notification channels created")
+    }
+
+    private fun createNotificationChannels() {
+        val notificationManager = getSystemService(NotificationManager::class.java)
+
+        val mcpServerChannel = NotificationChannel(
+            MCP_SERVER_CHANNEL_ID,
+            getString(R.string.notification_channel_mcp_server_name),
+            NotificationManager.IMPORTANCE_LOW,
+        ).apply {
+            description = "Notification for the running MCP server"
+        }
+
+        val screenCaptureChannel = NotificationChannel(
+            SCREEN_CAPTURE_CHANNEL_ID,
+            getString(R.string.notification_channel_screen_capture_name),
+            NotificationManager.IMPORTANCE_LOW,
+        ).apply {
+            description = "Notification for active screen capture"
+        }
+
+        notificationManager.createNotificationChannel(mcpServerChannel)
+        notificationManager.createNotificationChannel(screenCaptureChannel)
+    }
+
     companion object {
         private const val TAG = "MCP:Application"
+        const val MCP_SERVER_CHANNEL_ID = "mcp_server_channel"
+        const val SCREEN_CAPTURE_CHANNEL_ID = "screen_capture_channel"
     }
 }
```

> **Implementation Note**: The notification channel IDs (`mcp_server_channel`, `screen_capture_channel`) match the string resources defined in Plan 1's `strings.xml`. The `IMPORTANCE_LOW` level means notifications show in the status bar but do not make sound or vibrate, which is appropriate for persistent foreground service notifications.

> **IMPORTANT**: Notification channel creation is centralized HERE in `McpApplication.onCreate()`. Neither `McpServerService` nor `ScreenCaptureService` (Plan 5) create their own channels. Both services reference the channel IDs defined as constants in `McpApplication.Companion` (`MCP_SERVER_CHANNEL_ID`, `SCREEN_CAPTURE_CHANNEL_ID`). This ensures channels are created at application startup before any service calls `startForeground()`. If either service were to create its own channel, it would be redundant and violate the centralization principle.

---

### Task 6.7: Update Dependencies (if needed)

**Description**: Verify and update dependencies in `libs.versions.toml` and `app/build.gradle.kts` for new libraries required by this plan (Bouncy Castle for certificate generation, Ktor StatusPages plugin).

**Acceptance Criteria**:
- [ ] Add Bouncy Castle (`bcpkix-jdk18on` and `bcprov-jdk18on`) to `libs.versions.toml` and `app/build.gradle.kts` (REQUIRED for self-signed certificate generation with SAN support)
- [ ] `LocalBroadcastManager` is NOT used (replaced by StateFlow); do NOT add `localbroadcastmanager` dependency
- [ ] If Ktor `StatusPages` plugin requires a separate dependency (`ktor-server-status-pages`), add it
- [ ] If Ktor `CallLogging` plugin is used, add `ktor-server-call-logging` dependency
- [ ] All added dependencies use latest stable versions (verify at implementation time)
- [ ] `make build` succeeds after dependency changes

**Tests**: No tests for dependency changes. Build verification is sufficient.

#### Action 6.7.1: Verify and update `gradle/libs.versions.toml`

**What**: Check which additional dependencies are needed and add them to the version catalog.

**Context**: Plan 1 already includes Ktor server core, netty, content-negotiation, auth, TLS, and serialization. This action checks if additional dependencies are needed:

1. **Bouncy Castle** (`org.bouncycastle:bcpkix-jdk18on` and `bcprov-jdk18on`): REQUIRED for self-signed certificate generation with SAN support (used in `CertificateManager.generateSelfSignedCertificate()`).
2. **LocalBroadcastManager**: NOT needed -- replaced with `StateFlow` approach.
3. **Ktor StatusPages** (`io.ktor:ktor-server-status-pages`): Check if this is part of `ktor-server-core` or needs separate dependency in Ktor 3.x.

**File**: `gradle/libs.versions.toml` (conditional additions)

```diff
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ [versions] section - add:
+bouncy-castle = "1.78.1"               # verify latest at implementation time

@@ [libraries] section - add:
+# Certificate generation (REQUIRED for self-signed cert with SAN support)
+bouncy-castle-pkix = { group = "org.bouncycastle", name = "bcpkix-jdk18on", version.ref = "bouncy-castle" }
+bouncy-castle-prov = { group = "org.bouncycastle", name = "bcprov-jdk18on", version.ref = "bouncy-castle" }
+
+# Ktor additional plugins (add only if separate dependency needed in Ktor 3.x)
+ktor-server-status-pages = { group = "io.ktor", name = "ktor-server-status-pages", version.ref = "ktor" }
```

#### Action 6.7.2: Update `app/build.gradle.kts`

**What**: Add the new dependencies to the app module.

**File**: `app/build.gradle.kts` (conditional additions to dependencies block)

```diff
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ dependencies block - add:
+    // Certificate generation (REQUIRED for self-signed cert with SAN support)
+    implementation(libs.bouncy.castle.pkix)
+    implementation(libs.bouncy.castle.prov)
+
+    // Ktor additional plugins (add only if separate dependency needed)
+    implementation(libs.ktor.server.status.pages)
```

> **Implementation Note**: Bouncy Castle is REQUIRED (not conditional) -- standard JDK APIs do not support X.509 certificate generation with SAN extensions. The implementer should:
> 1. Add Bouncy Castle dependencies as shown above (verify latest version at implementation time)
> 2. Verify if `StatusPages` is already included in `ktor-server-core` for Ktor 3.x
> 3. `LocalBroadcastManager` is NOT used and should NOT be added -- replaced with StateFlow

---

### Task 6.8: Create Unit Tests

**Description**: Create unit tests for `McpProtocolHandler`, `BearerTokenAuth` (constant-time comparison function), and `CertificateManager`.

**Acceptance Criteria**:
- [ ] `McpProtocolHandlerTest`: All test cases pass (initialize, tools/list, tools/call, error codes, serialization)
- [ ] `BearerTokenAuthTest`: All test cases pass (valid/invalid/missing token, constant-time comparison)
- [ ] `CertificateManagerTest`: All test cases pass (cert generation, import, expiry validation)
- [ ] `make test-unit` passes
- [ ] No lint warnings

**Tests**: This task IS the tests.

#### Action 6.8.1: Create `McpProtocolHandlerTest.kt`

**What**: Create unit tests for the MCP JSON-RPC 2.0 protocol handler.

**Context**: Tests cover request routing, tool registration, initialize/tools-list/tools-call handlers, and all error factory methods. Uses JUnit 5 and kotlinx.serialization for JSON verification. The `McpProtocolHandler` is a pure Kotlin class with no Android dependencies (it uses `android.util.Log` which must be mocked).

**File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpProtocolHandlerTest.kt`

```diff
--- /dev/null
+++ b/app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/McpProtocolHandlerTest.kt
@@ -0,0 +1,202 @@
+package com.danielealbano.androidremotecontrolmcp.mcp
+
+import io.mockk.every
+import io.mockk.mockkStatic
+import io.mockk.unmockkStatic
+import kotlinx.coroutines.test.runTest
+import kotlinx.serialization.json.JsonObject
+import kotlinx.serialization.json.JsonPrimitive
+import kotlinx.serialization.json.buildJsonObject
+import kotlinx.serialization.json.int
+import kotlinx.serialization.json.jsonObject
+import kotlinx.serialization.json.jsonPrimitive
+import org.junit.jupiter.api.AfterEach
+import org.junit.jupiter.api.Assertions.assertEquals
+import org.junit.jupiter.api.Assertions.assertNotNull
+import org.junit.jupiter.api.Assertions.assertNull
+import org.junit.jupiter.api.BeforeEach
+import org.junit.jupiter.api.Test
+
+class McpProtocolHandlerTest {
+
+    private lateinit var handler: McpProtocolHandler
+
+    @BeforeEach
+    fun setUp() {
+        mockkStatic(android.util.Log::class)
+        every { android.util.Log.d(any(), any()) } returns 0
+        every { android.util.Log.i(any(), any()) } returns 0
+        every { android.util.Log.w(any(), any<String>()) } returns 0
+        every { android.util.Log.e(any(), any(), any()) } returns 0
+        every { android.util.Log.e(any(), any()) } returns 0
+
+        handler = McpProtocolHandler()
+    }
+
+    @AfterEach
+    fun tearDown() {
+        unmockkStatic(android.util.Log::class)
+    }
+
+    // --- handleInitialize tests ---
+
+    @Test
+    fun `handleRequest with initialize returns server info and capabilities`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(1),
+            method = McpProtocolHandler.METHOD_INITIALIZE,
+        )
+        val response = handler.handleRequest(request)
+
+        assertNull(response.error)
+        assertNotNull(response.result)
+        val result = response.result!!.jsonObject
+        assertEquals(McpProtocolHandler.PROTOCOL_VERSION, result["protocolVersion"]?.jsonPrimitive?.content)
+        assertEquals(McpProtocolHandler.SERVER_NAME, result["serverInfo"]?.jsonObject?.get("name")?.jsonPrimitive?.content)
+    }
+
+    // --- handleToolsList tests ---
+
+    @Test
+    fun `handleRequest with tools list returns empty list when no tools registered`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(2),
+            method = McpProtocolHandler.METHOD_TOOLS_LIST,
+        )
+        val response = handler.handleRequest(request)
+
+        assertNull(response.error)
+        assertNotNull(response.result)
+        val result = response.result!!.jsonObject
+        val tools = result["tools"]
+        assertNotNull(tools)
+    }
+
+    @Test
+    fun `handleRequest with tools list returns registered tools`() = runTest {
+        val schema = buildJsonObject {
+            put("type", JsonPrimitive("object"))
+        }
+        handler.registerTool("test_tool", "A test tool", schema, object : ToolHandler {
+            override suspend fun execute(params: JsonObject?): kotlinx.serialization.json.JsonElement =
+                buildJsonObject { put("result", JsonPrimitive("ok")) }
+        })
+
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(3),
+            method = McpProtocolHandler.METHOD_TOOLS_LIST,
+        )
+        val response = handler.handleRequest(request)
+
+        assertNull(response.error)
+        val result = response.result!!.jsonObject
+        val tools = result["tools"] as? kotlinx.serialization.json.JsonArray
+        assertNotNull(tools)
+        assertEquals(1, tools!!.size)
+        assertEquals("test_tool", tools[0].jsonObject["name"]?.jsonPrimitive?.content)
+    }
+
+    // --- handleToolCall tests ---
+
+    @Test
+    fun `handleRequest with tools call dispatches to registered handler`() = runTest {
+        val schema = buildJsonObject { put("type", JsonPrimitive("object")) }
+        handler.registerTool("echo_tool", "Echoes params", schema, object : ToolHandler {
+            override suspend fun execute(params: JsonObject?): kotlinx.serialization.json.JsonElement =
+                buildJsonObject { put("echo", JsonPrimitive("hello")) }
+        })
+
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(4),
+            method = McpProtocolHandler.METHOD_TOOLS_CALL,
+            params = buildJsonObject {
+                put("name", JsonPrimitive("echo_tool"))
+                put("arguments", buildJsonObject { })
+            },
+        )
+        val response = handler.handleRequest(request)
+
+        assertNull(response.error)
+        assertEquals("hello", response.result?.jsonObject?.get("echo")?.jsonPrimitive?.content)
+    }
+
+    @Test
+    fun `handleRequest with tools call returns method not found for unknown tool`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(5),
+            method = McpProtocolHandler.METHOD_TOOLS_CALL,
+            params = buildJsonObject {
+                put("name", JsonPrimitive("nonexistent_tool"))
+            },
+        )
+        val response = handler.handleRequest(request)
+
+        assertNotNull(response.error)
+        assertEquals(McpProtocolHandler.ERROR_METHOD_NOT_FOUND, response.error!!.code)
+    }
+
+    @Test
+    fun `handleRequest with tools call returns invalid params when params missing`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(6),
+            method = McpProtocolHandler.METHOD_TOOLS_CALL,
+            params = null,
+        )
+        val response = handler.handleRequest(request)
+
+        assertNotNull(response.error)
+        assertEquals(McpProtocolHandler.ERROR_INVALID_PARAMS, response.error!!.code)
+    }
+
+    @Test
+    fun `handleRequest with tools call returns invalid params when name missing`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(7),
+            method = McpProtocolHandler.METHOD_TOOLS_CALL,
+            params = buildJsonObject { },
+        )
+        val response = handler.handleRequest(request)
+
+        assertNotNull(response.error)
+        assertEquals(McpProtocolHandler.ERROR_INVALID_PARAMS, response.error!!.code)
+    }
+
+    // --- Unknown method test ---
+
+    @Test
+    fun `handleRequest with unknown method returns method not found`() = runTest {
+        val request = JsonRpcRequest(
+            id = JsonPrimitive(8),
+            method = "unknown/method",
+        )
+        val response = handler.handleRequest(request)
+
+        assertNotNull(response.error)
+        assertEquals(McpProtocolHandler.ERROR_METHOD_NOT_FOUND, response.error!!.code)
+    }
+
+    // --- Invalid JSON-RPC version test ---
+
+    @Test
+    fun `handleRequest with wrong jsonrpc version returns invalid request`() = runTest {
+        val request = JsonRpcRequest(
+            jsonrpc = "1.0",
+            id = JsonPrimitive(9),
+            method = "initialize",
+        )
+        val response = handler.handleRequest(request)
+
+        assertNotNull(response.error)
+        assertEquals(McpProtocolHandler.ERROR_INVALID_REQUEST, response.error!!.code)
+    }
+
+    // --- Error factory method tests ---
+
+    @Test
+    fun `parseError returns code -32700`() {
+        val response = handler.parseError(JsonPrimitive(10))
+        assertEquals(McpProtocolHandler.ERROR_PARSE, response.error!!.code)
+    }
+
+    @Test
+    fun `invalidRequest returns code -32600`() {
+        val response = handler.invalidRequest(JsonPrimitive(11))
+        assertEquals(McpProtocolHandler.ERROR_INVALID_REQUEST, response.error!!.code)
+    }
+
+    @Test
+    fun `methodNotFound returns code -32601`() {
+        val response = handler.methodNotFound(JsonPrimitive(12), "test")
+        assertEquals(McpProtocolHandler.ERROR_METHOD_NOT_FOUND, response.error!!.code)
+    }
+
+    @Test
+    fun `invalidParams returns code -32602`() {
+        val response = handler.invalidParams(JsonPrimitive(13), "bad param")
+        assertEquals(McpProtocolHandler.ERROR_INVALID_PARAMS, response.error!!.code)
+    }
+
+    @Test
+    fun `internalError returns code -32603`() {
+        val response = handler.internalError(JsonPrimitive(14), "oops")
+        assertEquals(McpProtocolHandler.ERROR_INTERNAL, response.error!!.code)
+    }
+
+    @Test
+    fun `permissionDenied returns code -32001`() {
+        val response = handler.permissionDenied(JsonPrimitive(15), "no access")
+        assertEquals(McpProtocolHandler.ERROR_PERMISSION_DENIED, response.error!!.code)
+    }
+
+    @Test
+    fun `elementNotFound returns code -32002`() {
+        val response = handler.elementNotFound(JsonPrimitive(16), "not found")
+        assertEquals(McpProtocolHandler.ERROR_ELEMENT_NOT_FOUND, response.error!!.code)
+    }
+
+    @Test
+    fun `actionFailed returns code -32003`() {
+        val response = handler.actionFailed(JsonPrimitive(17), "failed")
+        assertEquals(McpProtocolHandler.ERROR_ACTION_FAILED, response.error!!.code)
+    }
+
+    @Test
+    fun `timeoutError returns code -32004`() {
+        val response = handler.timeoutError(JsonPrimitive(18), "timed out")
+        assertEquals(McpProtocolHandler.ERROR_TIMEOUT, response.error!!.code)
+    }
+
+    // --- Response structure tests ---
+
+    @Test
+    fun `all responses include jsonrpc version 2_0`() = runTest {
+        val request = JsonRpcRequest(id = JsonPrimitive(19), method = "initialize")
+        val response = handler.handleRequest(request)
+        assertEquals("2.0", response.jsonrpc)
+    }
+
+    @Test
+    fun `all responses echo the request id`() = runTest {
+        val requestId = JsonPrimitive(42)
+        val request = JsonRpcRequest(id = requestId, method = "initialize")
+        val response = handler.handleRequest(request)
+        assertEquals(requestId, response.id)
+    }
+}
```

---

#### Action 6.8.2: Create `BearerTokenAuthTest.kt`

**What**: Create unit tests for the bearer token authentication logic, specifically the constant-time comparison function.

**Context**: Testing the full Ktor plugin requires a Ktor test engine (integration test territory). For unit tests, we test the `constantTimeEquals` function directly (it is `internal` visibility). The Ktor plugin behavior (intercepting routes, returning 401) is tested via integration tests.

**File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/auth/BearerTokenAuthTest.kt`

```diff
--- /dev/null
+++ b/app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/auth/BearerTokenAuthTest.kt
@@ -0,0 +1,64 @@
+package com.danielealbano.androidremotecontrolmcp.mcp.auth
+
+import org.junit.jupiter.api.Assertions.assertFalse
+import org.junit.jupiter.api.Assertions.assertTrue
+import org.junit.jupiter.api.Test
+
+class BearerTokenAuthTest {
+
+    // --- constantTimeEquals tests ---
+
+    @Test
+    fun `constantTimeEquals returns true for identical strings`() {
+        assertTrue(constantTimeEquals("my-secret-token", "my-secret-token"))
+    }
+
+    @Test
+    fun `constantTimeEquals returns false for different strings`() {
+        assertFalse(constantTimeEquals("my-secret-token", "wrong-token"))
+    }
+
+    @Test
+    fun `constantTimeEquals returns false for empty vs non-empty`() {
+        assertFalse(constantTimeEquals("my-secret-token", ""))
+    }
+
+    @Test
+    fun `constantTimeEquals returns true for both empty`() {
+        assertTrue(constantTimeEquals("", ""))
+    }
+
+    @Test
+    fun `constantTimeEquals returns false for strings differing in length`() {
+        assertFalse(constantTimeEquals("short", "a-much-longer-string"))
+    }
+
+    @Test
+    fun `constantTimeEquals returns false for strings differing by one character`() {
+        assertFalse(constantTimeEquals("abcdef", "abcdeg"))
+    }
+
+    @Test
+    fun `constantTimeEquals handles unicode strings`() {
+        assertTrue(constantTimeEquals("token-\u00e9\u00e8", "token-\u00e9\u00e8"))
+        assertFalse(constantTimeEquals("token-\u00e9\u00e8", "token-\u00e9\u00e7"))
+    }
+
+    @Test
+    fun `constantTimeEquals handles UUID-format tokens`() {
+        val token = "550e8400-e29b-41d4-a716-446655440000"
+        assertTrue(constantTimeEquals(token, token))
+        assertFalse(constantTimeEquals(token, "550e8400-e29b-41d4-a716-446655440001"))
+    }
+
+    // --- Timing consistency verification ---
+    // Note: True constant-time verification requires statistical analysis of timing
+    // measurements, which is impractical in a unit test. The test below verifies
+    // that MessageDigest.isEqual is being used (by checking the function produces
+    // correct results for edge cases that would differ between naive and constant-time
+    // implementations).
+
+    @Test
+    fun `constantTimeEquals returns correct result regardless of mismatch position`() {
+        val base = "abcdefghijklmnop"
+        // Mismatch at first character
+        assertFalse(constantTimeEquals(base, "Xbcdefghijklmnop"))
+        // Mismatch at last character
+        assertFalse(constantTimeEquals(base, "abcdefghijklmnoX"))
+        // Mismatch at middle character
+        assertFalse(constantTimeEquals(base, "abcdefgXijklmnop"))
+    }
+}
```

---

#### Action 6.8.3: Create `CertificateManagerTest.kt`

**What**: Create unit tests for the SSL certificate manager.

**Context**: Tests use a temporary directory for keystore files and mock the `SettingsRepository` for configuration. The `CertificateManager` uses `Context.getFilesDir()` which is mocked to return a temp directory. Tests cover keystore creation, certificate properties, and custom certificate import.

**File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/CertificateManagerTest.kt`

```diff
--- /dev/null
+++ b/app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/CertificateManagerTest.kt
@@ -0,0 +1,138 @@
+package com.danielealbano.androidremotecontrolmcp.mcp
+
+import android.content.Context
+import com.danielealbano.androidremotecontrolmcp.data.model.CertificateSource
+import com.danielealbano.androidremotecontrolmcp.data.model.ServerConfig
+import com.danielealbano.androidremotecontrolmcp.data.repository.SettingsRepository
+import io.mockk.every
+import io.mockk.mockk
+import io.mockk.mockkStatic
+import io.mockk.unmockkStatic
+import kotlinx.coroutines.flow.flowOf
+import org.junit.jupiter.api.AfterEach
+import org.junit.jupiter.api.Assertions.assertEquals
+import org.junit.jupiter.api.Assertions.assertNotNull
+import org.junit.jupiter.api.Assertions.assertTrue
+import org.junit.jupiter.api.BeforeEach
+import org.junit.jupiter.api.Test
+import org.junit.jupiter.api.io.TempDir
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.security.KeyStore
+import java.security.cert.X509Certificate
+import java.util.Calendar
+import java.util.Date
+
+class CertificateManagerTest {
+
+    @TempDir
+    lateinit var tempDir: File
+
+    private lateinit var context: Context
+    private lateinit var settingsRepository: SettingsRepository
+    private lateinit var certificateManager: CertificateManager
+
+    @BeforeEach
+    fun setUp() {
+        mockkStatic(android.util.Log::class)
+        every { android.util.Log.d(any(), any()) } returns 0
+        every { android.util.Log.i(any(), any()) } returns 0
+        every { android.util.Log.w(any(), any<String>()) } returns 0
+        every { android.util.Log.w(any(), any<String>(), any()) } returns 0
+        every { android.util.Log.e(any(), any()) } returns 0
+        every { android.util.Log.e(any(), any(), any()) } returns 0
+
+        context = mockk(relaxed = true) {
+            every { filesDir } returns tempDir
+        }
+        settingsRepository = mockk {
+            every { serverConfig } returns flowOf(
+                ServerConfig(certificateSource = CertificateSource.AUTO_GENERATED),
+            )
+        }
+
+        certificateManager = CertificateManager(context, settingsRepository)
+    }
+
+    @AfterEach
+    fun tearDown() {
+        unmockkStatic(android.util.Log::class)
+    }
+
+    @Test
+    fun `getKeyStorePassword generates and persists password`() {
+        val password1 = certificateManager.getKeyStorePassword()
+        val password2 = certificateManager.getKeyStorePassword()
+
+        assertTrue(password1.isNotEmpty())
+        assertEquals(String(password1), String(password2))
+    }
+
+    @Test
+    fun `getKeyStorePassword generates password of expected length`() {
+        val password = certificateManager.getKeyStorePassword()
+        // 32 bytes * 2 hex chars per byte = 64 characters
+        assertEquals(CertificateManager.PASSWORD_LENGTH * 2, password.size)
+    }
+
+    @Test
+    fun `password file is created in filesDir`() {
+        certificateManager.getKeyStorePassword()
+        val passwordFile = File(tempDir, CertificateManager.KEYSTORE_PASSWORD_FILENAME)
+        assertTrue(passwordFile.exists())
+    }
+
+    // --- Certificate generation tests ---
+    // These tests require Bouncy Castle on the test classpath.
+    // Ensure bcpkix-jdk18on and bcprov-jdk18on are in testImplementation.
+
+    @Test
+    fun `generateSelfSignedCertificate creates keystore file`() {
+        certificateManager.generateSelfSignedCertificate("test.local")
+        val keystoreFile = File(tempDir, CertificateManager.KEYSTORE_FILENAME)
+        assertTrue(keystoreFile.exists())
+    }
+
+    @Test
+    fun `generateSelfSignedCertificate creates certificate with correct CN`() {
+        val keyStore = certificateManager.generateSelfSignedCertificate("test.local")
+        val cert = keyStore.getCertificate(CertificateManager.KEY_ALIAS) as X509Certificate
+        assertNotNull(cert)
+        assertTrue(
+            cert.subjectX500Principal.name.contains("CN=test.local"),
+            "Certificate CN should contain test.local, got: ${cert.subjectX500Principal.name}",
+        )
+    }
+
+    @Test
+    fun `generateSelfSignedCertificate creates certificate valid for 1 year`() {
+        val beforeGeneration = Date()
+        val keyStore = certificateManager.generateSelfSignedCertificate("test.local")
+        val cert = keyStore.getCertificate(CertificateManager.KEY_ALIAS) as X509Certificate
+
+        // Certificate should not be expired
+        cert.checkValidity()
+
+        // Certificate should expire roughly 1 year from now
+        val expectedExpiry = Calendar.getInstance().apply {
+            time = beforeGeneration
+            add(Calendar.YEAR, 1)
+        }.time
+        // Allow 1 minute tolerance for test execution time
+        val toleranceMs = 60_000L
+        assertTrue(
+            kotlin.math.abs(cert.notAfter.time - expectedExpiry.time) < toleranceMs,
+            "Certificate should expire ~1 year from now",
+        )
+    }
+
+    @Test
+    fun `generateSelfSignedCertificate creates RSA 2048-bit key`() {
+        val keyStore = certificateManager.generateSelfSignedCertificate("test.local")
+        val key = keyStore.getKey(CertificateManager.KEY_ALIAS, certificateManager.getKeyStorePassword())
+        assertNotNull(key)
+        assertEquals("RSA", key.algorithm)
+    }
+
+    // --- Custom certificate import tests ---
+
+    @Test
+    fun `importCustomCertificate with wrong password returns failure`() {
+        // Create a valid PKCS12 keystore with known password
+        val keyStore = KeyStore.getInstance("PKCS12")
+        keyStore.load(null, "correct-password".toCharArray())
+
+        val baos = ByteArrayOutputStream()
+        keyStore.store(baos, "correct-password".toCharArray())
+        val keystoreBytes = baos.toByteArray()
+
+        // Try to import with wrong password
+        val result = certificateManager.importCustomCertificate(keystoreBytes, "wrong-password")
+
+        assertTrue(result.isFailure)
+    }
+
+    @Test
+    fun `importCustomCertificate with valid empty keystore succeeds`() {
+        // Create a valid but empty PKCS12 keystore
+        val keyStore = KeyStore.getInstance("PKCS12")
+        keyStore.load(null, "test-password".toCharArray())
+
+        val baos = ByteArrayOutputStream()
+        keyStore.store(baos, "test-password".toCharArray())
+        val keystoreBytes = baos.toByteArray()
+
+        val result = certificateManager.importCustomCertificate(keystoreBytes, "test-password")
+
+        assertTrue(result.isSuccess)
+    }
+
+    @Test
+    fun `importCustomCertificate stores file in filesDir`() {
+        val keyStore = KeyStore.getInstance("PKCS12")
+        keyStore.load(null, "test-password".toCharArray())
+
+        val baos = ByteArrayOutputStream()
+        keyStore.store(baos, "test-password".toCharArray())
+
+        certificateManager.importCustomCertificate(baos.toByteArray(), "test-password")
+
+        val customFile = File(tempDir, CertificateManager.CUSTOM_KEYSTORE_FILENAME)
+        assertTrue(customFile.exists())
+    }
+}
```

> **Implementation Note**: Certificate generation tests use Bouncy Castle (available on the test classpath via `testImplementation` dependencies). Tests verify CN, validity period, and key algorithm. At implementation time, consider also adding:
> - Certificate SAN verification (requires Bouncy Castle's `X509CertificateHolder` to parse SAN extension)
> - Expired certificate import rejection test (requires generating an expired test certificate)

---

### Task 6.9: Create Architecture Documentation

**Description**: Create `docs/ARCHITECTURE.md` documenting the runtime architecture, component interactions, service lifecycle, threading model, data flow, and security model.

**Acceptance Criteria**:
- [ ] Document covers application overview and purpose
- [ ] Document includes component diagram (text-based)
- [ ] Document explains service lifecycle in detail
- [ ] Document describes inter-service communication patterns
- [ ] Document explains threading model
- [ ] Document describes MCP request data flow
- [ ] Document covers security model (HTTPS, bearer token, network exposure)
- [ ] Document explains configuration flow
- [ ] Document describes permission model
- [ ] Document does not duplicate content from PROJECT.md (focuses on HOW, not WHAT)

**Tests**: No tests for documentation. Review only.

#### Action 6.9.1: Create `docs/ARCHITECTURE.md`

**What**: Create comprehensive architecture documentation.

**Context**: This document explains HOW the architecture works at runtime (component interactions, data flow, threading). PROJECT.md describes WHAT the architecture is (design decisions, specifications). ARCHITECTURE.md should be useful for developers who need to understand the runtime behavior of the application.

**File**: `docs/ARCHITECTURE.md`

```diff
--- /dev/null
+++ b/docs/ARCHITECTURE.md
@@ -0,0 +1,280 @@
+# Application Architecture
+
+This document describes the runtime architecture of the Android Remote Control MCP application.
+It focuses on **how** components interact at runtime rather than **what** they are
+(for design decisions and specifications, see [PROJECT.md](PROJECT.md)).
+
+---
+
+## Component Diagram
+
+```
++------------------------------------------------------------+
+|                    Android Device                           |
+|                                                            |
+|  +------------------+    +---------------------------+     |
+|  |   MainActivity   |    |  McpAccessibilityService  |     |
+|  |  (Compose UI)    |    |  (System-managed)         |     |
+|  |                  |    |                           |     |
+|  |  MainViewModel   |    |  - TreeParser             |     |
+|  |  - Settings      |    |  - ElementFinder          |     |
+|  |  - Status        |    |  - ActionExecutor         |     |
+|  +-------+----------+    +----------+----------------+     |
+|          |                           |                     |
+|          | StateFlow                 | Singleton            |
+|          | (status)                  | (companion object)   |
+|          |                           |                     |
+|  +-------v---------------------------v----------------+    |
+|  |              McpServerService                      |    |
+|  |              (Foreground Service)                   |    |
+|  |                                                    |    |
+|  |  +--------------------------------------------+   |    |
+|  |  |            McpServer (Ktor)                 |   |    |
+|  |  |  HTTP :8080 (HTTPS optional)                |   |    |
+|  |  |                                            |   |    |
+|  |  |  GET  /health           (unauthenticated)  |   |    |
+|  |  |  POST /mcp/v1/initialize (bearer token)    |   |    |
+|  |  |  GET  /mcp/v1/tools/list (bearer token)    |   |    |
+|  |  |  POST /mcp/v1/tools/call (bearer token)    |   |    |
+|  |  |                                            |   |    |
+|  |  |  BearerTokenAuth -> McpProtocolHandler     |   |    |
+|  |  |                    -> ToolHandlers          |   |    |
+|  |  +--------------------------------------------+   |    |
+|  |                                                    |    |
+|  +----+----------------------------------------------+    |
+|       |                                                    |
+|       | Bound Service                                      |
+|       |                                                    |
+|  +----v-------------------------------------------+       |
+|  |          ScreenCaptureService                   |       |
+|  |          (Foreground Service)                    |       |
+|  |                                                 |       |
+|  |  MediaProjection -> ImageReader -> JPEG encode  |       |
+|  +-------------------------------------------------+       |
+|                                                            |
++------------------------------------------------------------+
+         |
+         | HTTP (or HTTPS/TLS 1.2+ if enabled)
+         |
+    +----v----+
+    |  MCP    |
+    |  Client |
+    |  (AI)   |
+    +---------+
+```
+
+---
+
+## Service Lifecycle
+
+### Startup Sequence
+
+1. **User opens app** -> `MainActivity.onCreate()` renders Compose UI
+2. **User enables accessibility** -> System starts `McpAccessibilityService`
+   - `onServiceConnected()` stores `instance` in companion object
+   - Service remains running until disabled in Settings
+3. **User grants MediaProjection** -> Permission stored for `ScreenCaptureService`
+4. **User taps "Start Server"** -> `MainViewModel.startServer()` called
+   - Sends `ACTION_START` intent to `McpServerService`
+   - `McpServerService.onStartCommand()`:
+     a. Calls `startForeground()` with notification (within 5 seconds)
+     b. Reads `ServerConfig` from `SettingsRepository`
+     c. Gets/creates SSL keystore from `CertificateManager`
+     d. Creates `McpServer` with config, keystore, and `McpProtocolHandler`
+     e. Binds to `ScreenCaptureService` via `ServiceConnection`
+     f. Starts Ktor server (HTTP by default, HTTPS if enabled)
+     g. Updates `ServerStatus.Running` via companion-level StateFlow
+
+### Shutdown Sequence
+
+1. **User taps "Stop Server"** -> `MainViewModel.stopServer()` called
+   - Sends `ACTION_STOP` intent to `McpServerService`
+   - `McpServerService.onDestroy()`:
+     a. Updates `ServerStatus.Stopping` via companion-level StateFlow
+     b. Stops Ktor server gracefully (1s grace + 5s timeout)
+     c. Unbinds from `ScreenCaptureService`
+     d. Cancels coroutine scope
+     e. Clears singleton instance
+     f. Updates `ServerStatus.Stopped` via companion-level StateFlow
+
+### Auto-Start on Boot
+
+1. Device boots -> Android delivers `BOOT_COMPLETED` broadcast
+2. `BootCompletedReceiver.onReceive()`:
+   a. Reads auto-start setting from `SettingsRepository`
+   b. If enabled: starts `McpServerService` via `startForegroundService()`
+   c. If disabled: does nothing
+
+---
+
+## Threading Model
+
+### Thread Assignments
+
+| Thread/Dispatcher     | Responsibilities                                        |
+|-----------------------|---------------------------------------------------------|
+| Main Thread           | Compose UI, Activity lifecycle, AccessibilityService    |
+|                       | node operations, `onAccessibilityEvent()`               |
+| Dispatchers.IO        | DataStore reads/writes, Ktor server startup, network I/O|
+| Dispatchers.Default   | Screenshot JPEG encoding, accessibility tree parsing    |
+| Ktor Netty threads    | HTTP request handling (NIO event loop)                  |
+
+### Coroutine Scopes
+
+| Component             | Scope                      | Lifecycle                    |
+|-----------------------|---------------------------|------------------------------|
+| MainViewModel         | `viewModelScope`          | ViewModel lifecycle          |
+| McpServerService      | Custom `CoroutineScope`   | Service onCreate to onDestroy|
+| McpAccessibilityService| Custom `CoroutineScope`  | Service lifecycle            |
+| ScreenCaptureService  | Custom `CoroutineScope`   | Service lifecycle            |
+
+### Thread Safety
+
+- `McpProtocolHandler.tools` registry: `ConcurrentHashMap` (lock-free reads)
+- `McpAccessibilityService.instance`: `@Volatile` singleton
+- `McpServer.running`: `AtomicBoolean`
+- Accessibility node access: Must be on main thread (Android requirement)
+
+---
+
+## Data Flow: MCP Request
+
+```
+MCP Client
+    |
+    | HTTP(S) POST /mcp/v1/tools/call
+    | Authorization: Bearer <token>
+    | { "jsonrpc": "2.0", "id": 1, "method": "tools/call",
+    |   "params": { "name": "tap", "arguments": { "x": 500, "y": 1000 } } }
+    v
+Ktor Netty (IO threads)
+    |
+    | ContentNegotiation: deserialize JSON -> JsonRpcRequest
+    v
+BearerTokenAuth Plugin
+    |
+    | Extract "Authorization: Bearer <token>" header
+    | Constant-time compare with stored token
+    | If invalid -> respond 401, stop pipeline
+    v
+Route Handler (/mcp/v1/tools/call)
+    |
+    | call.receive<JsonRpcRequest>()
+    v
+McpProtocolHandler.handleRequest()
+    |
+    | Route by method ("tools/call")
+    | Extract tool name ("tap") and arguments
+    | Look up ToolHandler from registry
+    v
+ToolHandler.execute(params)  [e.g., TouchActionTools]
+    |
+    | withContext(Dispatchers.Main) {
+    |     McpAccessibilityService.instance?.dispatchGesture(...)
+    | }
+    v
+AccessibilityService (Main Thread)
+    |
+    | Performs gesture on Android UI
+    | Returns success/failure
+    v
+ToolHandler returns JsonElement result
+    |
+    v
+McpProtocolHandler wraps in JsonRpcResponse
+    |
+    v
+Ktor Netty
+    |
+    | ContentNegotiation: serialize JsonRpcResponse -> JSON
+    | Respond with HTTP 200
+    v
+MCP Client receives response
+```
+
+---
+
+## Security Model
+
+### HTTPS (Optional Transport Security)
+
+- When HTTPS is enabled, all traffic encrypted with TLS 1.2+
+- Self-signed or custom certificate (when HTTPS is enabled)
+- HTTP by default; HTTPS available as optional toggle in settings
+- Certificate stored in app-private directory
+
+### Bearer Token (Authentication)
+
+- Every `/mcp/*` request requires `Authorization: Bearer <token>` header
+- Token validated with constant-time comparison (prevents timing attacks)
+- Token auto-generated (UUID) on first launch, user can regenerate
+- Token stored in DataStore (app-private)
+
+### Network Binding (Exposure Control)
+
+- Default: `127.0.0.1` (localhost only, requires `adb forward`)
+- Optional: `0.0.0.0` (all interfaces, with security warning)
+- No external firewall; relies on Android's app sandbox and bearer token
+
+---
+
+## Configuration Flow
+
+```
+User (UI)
+    |
+    v
+MainViewModel
+    |
+    | updatePort(), updateBindingAddress(), etc.
+    v
+SettingsRepository (interface)
+    |
+    v
+SettingsRepositoryImpl (DataStore<Preferences>)
+    |
+    | Persists to DataStore file
+    | Emits via serverConfig: Flow<ServerConfig>
+    v
+McpServerService (reads on start)
+    |
+    | config = settingsRepository.serverConfig.first()
+    v
+McpServer (uses config for Ktor setup)
+```
+
+Settings are read at server start time. Changing settings while the server is
+running requires a restart (UI disables config editing when server is running).
+
+---
+
+## Permission Model
+
+| Permission               | Type          | How Granted                        | Required For              |
+|--------------------------|---------------|------------------------------------|---------------------------|
+| INTERNET                 | Normal        | Auto-granted (manifest)            | HTTP server               |
+| FOREGROUND_SERVICE       | Normal        | Auto-granted (manifest)            | Foreground services       |
+| RECEIVE_BOOT_COMPLETED   | Normal        | Auto-granted (manifest)            | Auto-start on boot        |
+| POST_NOTIFICATIONS       | Runtime (13+) | System dialog                      | Foreground notifications  |
+| Accessibility Service    | Special       | User enables in Settings           | UI introspection/actions  |
+| MediaProjection          | Special       | User confirms system dialog        | Screenshots               |
+
+---
+
+**End of ARCHITECTURE.md**
```

---

### Task 6.10: Final Verification

**Description**: Run linting, unit tests, and build to verify all changes compile and pass quality gates.

**Acceptance Criteria**:
- [ ] `make lint` passes with no errors or warnings
- [ ] `make test-unit` passes with all tests green
- [ ] `make build` succeeds with no errors or warnings

#### Action 6.10.1: Run linting

**What**: Execute lint checks to ensure code style compliance.

```bash
make lint
```

If lint issues are found, fix them with `make lint-fix` where possible, then manually fix remaining issues.

#### Action 6.10.2: Run unit tests

**What**: Execute all unit tests to verify correctness.

```bash
make test-unit
```

All tests from Plans 1-6 must pass. If any test fails, fix the root cause.

#### Action 6.10.3: Run build

**What**: Build the debug APK to verify compilation.

```bash
make build
```

The build must complete with no errors and no warnings.

---

## Performance, Security, and QA Review

### Performance Considerations

1. **Ktor Netty NIO**: The server uses Netty's non-blocking I/O, which efficiently handles concurrent MCP requests without thread-per-request overhead. This is appropriate for an Android device with limited resources.

2. **ConcurrentHashMap for tool registry**: The `McpProtocolHandler` uses `ConcurrentHashMap` for lock-free reads during tool dispatch. Since tools are registered at startup and only read during request handling, this provides optimal read performance.

3. **Coroutine-based request handling**: All MCP request handling is suspending, allowing efficient use of limited thread pools. Long-running operations (screenshot encoding, accessibility tree parsing) use appropriate dispatchers.

4. **Certificate loading**: `CertificateManager.getOrCreateKeyStore()` is called once at server start, not per-request. The keystore is loaded into memory and passed to Ktor.

5. **Potential concern -- `runBlocking` in `CertificateManager`**: The `getOrCreateKeyStore()` method uses `runBlocking` to read settings synchronously. This is acceptable because it runs on the IO dispatcher during server startup (not on the main thread). However, at implementation time, consider making this method `suspend` and calling it from a coroutine context.

### Security Considerations

1. **Constant-time token comparison**: `BearerTokenAuth` uses `MessageDigest.isEqual()` for token validation, preventing timing side-channel attacks. This is verified by unit tests.

2. **HTTPS optional**: The server defaults to HTTP. When HTTPS is enabled in settings, all traffic is encrypted with TLS.

3. **Keystore password storage**: The keystore password is stored in plaintext in app-private storage. This is acceptable given Android's application sandbox but could be improved with Android Keystore or EncryptedFile in a future iteration.

4. **Token not logged**: Authentication failures log the remote address but never the token value (neither expected nor provided).

5. **Error messages**: Error responses do not leak internal implementation details (stack traces, class names, file paths). Only generic error messages are returned to clients.

6. **Service singleton**: `McpServerService.instance` is `@Volatile` for thread-safe reads across threads.

### QA Considerations

1. **Test coverage**: Unit tests cover the protocol handler (request routing, error codes, tool dispatch), authentication (constant-time comparison), and certificate manager (password generation, keystore creation, custom import). Integration tests (deferred) will cover the full Ktor server pipeline.

2. **Edge cases tested**: Invalid JSON-RPC version, missing params, unknown methods, wrong passwords, empty keystores.

3. **Graceful degradation**: If `ScreenCaptureService` binding fails, the MCP server still starts (screenshot tools will return permission errors). If certificate generation fails, the error is caught and reported to the UI.

4. **Service lifecycle**: `onDestroy()` cleans up all resources (server, bindings, coroutines, singleton). `startForeground()` is called immediately in `onStartCommand()` to meet the 5-second requirement.

5. **Missing test scenarios to add at implementation time**:
   - Certificate SAN verification (Bouncy Castle now available, can parse SAN extension)
   - Expired certificate import rejection
   - Ktor server integration test with test engine
   - Concurrent MCP request handling
   - Server start/stop rapid cycling (idempotency)

---

**End of Plan 6**
