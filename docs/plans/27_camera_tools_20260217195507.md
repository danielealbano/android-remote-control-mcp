# Plan 27 — Camera Tools (MCP Tool Category 10)

**Created**: 2026-02-17 19:55:07
**Status**: In Progress
**Summary**: Add 6 new MCP camera tools enabling AI models to list cameras, query supported resolutions, take photos (inline base64 or saved to storage), and record video (saved to storage with thumbnail). Uses CameraX API, requires CAMERA and RECORD_AUDIO runtime permissions.

---

## Context & Decisions

### Agreed Design

- **6 new MCP tools** in a new category "Camera Tools" (category 10):
  1. `android_list_cameras` — enumerate available cameras
  2. `android_list_camera_photo_resolutions` — photo resolutions for a specific camera
  3. `android_list_camera_video_resolutions` — video resolutions for a specific camera
  4. `android_take_camera_photo` — capture photo, return as base64 `ImageContent` (JPEG)
  5. `android_save_camera_photo` — capture photo, save to a user storage location
  6. `android_save_camera_video` — record video (max 30s), save to a user storage location, return thumbnail as `ImageContent`

- **Camera API**: CameraX (Jetpack) — Google-recommended, handles lifecycle, works without preview surface
- **Service lifecycle**: CameraX requires a `LifecycleOwner`. `McpServerService` is a plain `Service`, so a custom `ServiceLifecycleOwner` will be created
- **Camera lifecycle per request**: open camera, capture, close — no persistent camera session between requests
- **Concurrency**: `Mutex` with timeout to serialize camera access (same pattern as text input serialization). Timeout: 45 seconds for photo operations, 45 seconds + requested duration for video operations. Prevents indefinite blocking if a camera operation hangs.
- **Default resolution**: 720p (closest available match) for both photo and video
- **Flash**: exposed as parameter, default `auto`
- **Photo quality**: JPEG, default 80 (1-100)
- **Video**: always saves to storage (no inline return — MCP has no video content type), max 30 seconds, includes audio by default
- **Video thumbnail**: first frame extracted and returned as `ImageContent` alongside success text
- **Permissions**: `CAMERA` (runtime dangerous) + `RECORD_AUDIO` (runtime dangerous) — both added to UI permissions section
- **Storage**: save tools require `location_id` + `path`, respect per-location write permissions
- **Tool naming**: follows `android_` prefix convention with device slug support
- **Inline photo max resolution**: `take_camera_photo` (base64 return) caps resolution at 1920x1080 to prevent excessively large JSON responses. The `save_camera_photo` (storage save) has no such cap.
- **FileOperationProvider extension**: A new `createFileUri(locationId, path, mimeType)` method must be added to `FileOperationProvider` interface and implementation, returning a `Uri` that CameraX can write to. This is required by the `save_camera_photo` and `save_camera_video` tools.

### Technical Notes

- CameraX `ImageCapture` use case captures still images without a preview surface
- CameraX `VideoCapture<Recorder>` use case records video without a preview surface
- `ProcessCameraProvider` binds use cases to a lifecycle owner
- For selecting closest resolution to 720p: use CameraX `ResolutionSelector` with `ResolutionStrategy.CLOSEST_HIGHER_THEN_LOWER`
- Video thumbnail extraction uses `MediaMetadataRetriever.getFrameAtTime(0)` after recording
- Camera enumeration via `ProcessCameraProvider.availableCameraInfos` (returns ALL cameras), with `Camera2CameraInfo` for hardware ID and lens facing

---

## Files Impacted

| File | Action |
|------|--------|
| `gradle/libs.versions.toml` | Modify — add CameraX dependency versions |
| `app/build.gradle.kts` | Modify — add CameraX dependency references |
| `app/src/main/AndroidManifest.xml` | Modify — add CAMERA and RECORD_AUDIO permissions, camera features |
| `app/src/main/res/values/strings.xml` | Modify — add camera permission string resources |
| `app/src/main/kotlin/.../data/model/CameraInfo.kt` | Create — camera info data model |
| `app/src/main/kotlin/.../data/model/CameraResolution.kt` | Create — photo/video resolution data models |
| `app/src/main/kotlin/.../services/camera/CameraProvider.kt` | Create — camera service interface |
| `app/src/main/kotlin/.../services/camera/CameraProviderImpl.kt` | Create — CameraX-based implementation |
| `app/src/main/kotlin/.../services/camera/ServiceLifecycleOwner.kt` | Create — LifecycleOwner adapter for Service context |
| `app/src/main/kotlin/.../mcp/tools/CameraTools.kt` | Create — 6 MCP tool handlers + registration function |
| `app/src/main/kotlin/.../di/AppModule.kt` | Modify — bind CameraProvider interface to implementation |
| `app/src/main/kotlin/.../services/mcp/McpServerService.kt` | Modify — inject CameraProvider, call registerCameraTools() |
| `app/src/main/kotlin/.../utils/PermissionUtils.kt` | Modify — add camera and microphone permission checks |
| `app/src/main/kotlin/.../ui/viewmodels/MainViewModel.kt` | Modify — add camera/microphone permission state flows |
| `app/src/main/kotlin/.../ui/components/PermissionsSection.kt` | Modify — add camera and microphone permission rows |
| `app/src/main/kotlin/.../ui/screens/HomeScreen.kt` | Modify — add camera/microphone permission callback parameters |
| `app/src/main/kotlin/.../ui/MainActivity.kt` | Modify — add camera/microphone permission launchers, pass callbacks to HomeScreen |
| `app/src/main/kotlin/.../services/storage/FileOperationProvider.kt` | Modify — add `createFileUri` method |
| `app/src/main/kotlin/.../services/storage/FileOperationProviderImpl.kt` | Modify — implement `createFileUri` method |
| `app/src/test/kotlin/.../services/storage/FileOperationProviderTest.kt` | Modify — add `createFileUri` unit tests |
| `app/src/test/kotlin/.../integration/McpIntegrationTestHelper.kt` | Modify — add CameraProvider to MockDependencies |
| `app/src/test/kotlin/.../services/camera/ServiceLifecycleOwnerTest.kt` | Create — unit tests for ServiceLifecycleOwner |
| `app/src/test/kotlin/.../services/camera/CameraProviderImplTest.kt` | Create — unit tests for CameraProviderImpl |
| `app/src/test/kotlin/.../mcp/tools/CameraToolsTest.kt` | Create — unit tests for camera tool handlers |
| `app/src/test/kotlin/.../integration/CameraToolsIntegrationTest.kt` | Create — integration tests |
| `docs/PROJECT.md` | Modify — add Camera Tools to MCP Tools Specification section |
| `docs/MCP_TOOLS.md` | Modify — add Camera Tools section (category 10) |
| `docs/ARCHITECTURE.md` | Modify — add camera service to component diagram and permission model |

---

## User Story 1: CameraX Dependencies and Android Permissions

**Goal**: Add CameraX library dependencies and declare the required Android permissions so the app can access device cameras.

### Acceptance Criteria
- [x] CameraX dependencies (camera-core, camera-camera2, camera-lifecycle, camera-video) are declared in the version catalog and build file
- [x] `CAMERA` permission is declared in `AndroidManifest.xml`
- [x] `RECORD_AUDIO` permission is declared in `AndroidManifest.xml`
- [x] `<uses-feature android:name="android.hardware.camera" android:required="false" />` is declared (camera is optional, app works without it)
- [x] `<uses-feature android:name="android.hardware.microphone" android:required="false" />` is declared
- [x] Project builds without errors: `./gradlew assembleDebug`
- [x] Linting passes: `./gradlew ktlintCheck detekt`

### Task 1.1: Add CameraX dependencies to version catalog

**Definition of Done**: CameraX version and library entries exist in `gradle/libs.versions.toml`.

#### Action 1.1.1: Add CameraX version to `[versions]` section

- **File**: `gradle/libs.versions.toml`
- **What**: Add CameraX version entry after the `documentfile` entry in the `# AndroidX` section.
- **Change**: Add line `camerax = "1.5.2"` (latest stable CameraX with full Video support).

> **Note**: CameraX 1.5.2 is the latest stable release (as of Feb 2026). Before implementing, verify no newer stable version is available via `https://developer.android.com/jetpack/androidx/releases/camera`.

#### Action 1.1.2: Add CameraX library entries to `[libraries]` section

- **File**: `gradle/libs.versions.toml`
- **What**: Add 4 CameraX library entries after the `# DocumentFile (SAF)` section.
- **Change**: Add a new `# CameraX` section with:
  ```toml
  # CameraX
  camerax-core = { group = "androidx.camera", name = "camera-core", version.ref = "camerax" }
  camerax-camera2 = { group = "androidx.camera", name = "camera-camera2", version.ref = "camerax" }
  camerax-lifecycle = { group = "androidx.camera", name = "camera-lifecycle", version.ref = "camerax" }
  camerax-video = { group = "androidx.camera", name = "camera-video", version.ref = "camerax" }
  ```

### Task 1.2: Add CameraX dependencies to app build file

**Definition of Done**: CameraX dependencies are referenced in `app/build.gradle.kts` `dependencies` block.

#### Action 1.2.1: Add CameraX implementation dependencies

- **File**: `app/build.gradle.kts`
- **What**: Add 4 `implementation` lines for CameraX in the `dependencies` block, after the existing `// DocumentFile (SAF)` entry.
- **Change**: Add:
  ```kotlin
  // CameraX
  implementation(libs.camerax.core)
  implementation(libs.camerax.camera2)
  implementation(libs.camerax.lifecycle)
  implementation(libs.camerax.video)
  ```

### Task 1.3: Add permissions to AndroidManifest.xml

**Definition of Done**: CAMERA and RECORD_AUDIO permissions and optional hardware features are declared.

#### Action 1.3.1: Add CAMERA and RECORD_AUDIO permissions

- **File**: `app/src/main/AndroidManifest.xml`
- **What**: Add permission declarations after the existing `<!-- App Management -->` section (after `KILL_BACKGROUND_PROCESSES`).
- **Change**: Add:
  ```xml
  <!-- Camera -->
  <uses-permission android:name="android.permission.CAMERA" />
  <uses-permission android:name="android.permission.RECORD_AUDIO" />
  
  <uses-feature android:name="android.hardware.camera" android:required="false" />
  <uses-feature android:name="android.hardware.microphone" android:required="false" />
  ```
  The `android:required="false"` ensures the app can be installed on devices without cameras (the tools will return appropriate errors).

### Task 1.4: Run build and lint verification

**Definition of Done**: Project builds and lint passes.

#### Action 1.4.1: Verify build

- **Command**: `./gradlew assembleDebug`
- **Expected**: BUILD SUCCESSFUL

#### Action 1.4.2: Verify lint

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No new warnings or errors

---

## User Story 2: Camera Service Layer (Interface + Implementation)

**Goal**: Create the `CameraProvider` interface and its CameraX-based implementation that handles camera enumeration, photo capture, and video recording.

### Acceptance Criteria
- [ ] `CameraInfo` data model is created with camera ID, facing direction, flash support, photo/video support
- [ ] `CameraResolution` data models are created for photo and video resolutions
- [ ] `CameraProvider` interface is created with methods: `listCameras()`, `listPhotoResolutions(cameraId)`, `listVideoResolutions(cameraId)`, `takePhoto(cameraId, resolution, quality, flashMode)`, `savePhoto(cameraId, resolution, quality, flashMode, outputUri)`, `saveVideo(cameraId, resolution, durationSeconds, audio, flashMode, outputUri)`, `isCameraPermissionGranted()`, `isMicrophonePermissionGranted()`
- [ ] `ServiceLifecycleOwner` is created to adapt `Service` to `LifecycleOwner` for CameraX, with proper lifecycle state transitions (INITIALIZED → CREATED → STARTED → RESUMED for start; RESUMED → STARTED → CREATED → DESTROYED for stop)
- [ ] Unit tests for `ServiceLifecycleOwner` pass
- [ ] `CameraProviderImpl` is created using CameraX API
- [ ] Camera access is serialized via `Mutex` with timeout (45s for photos, 45s + duration for videos) to prevent indefinite blocking
- [ ] Camera is opened and closed per request (no persistent session)
- [ ] Default resolution is 720p closest match
- [ ] `takePhoto` (inline) caps resolution at 1920x1080 max; `savePhoto` has no cap
- [ ] Flash mode supports `off`, `on`, `auto` (default `auto`)
- [ ] Photo capture returns `ScreenshotData` (base64 JPEG) or writes to URI
- [ ] Video recording respects max 30 second duration
- [ ] Video recording includes audio by default (when `audio=true`)
- [ ] Video thumbnail is extracted as first frame after recording
- [ ] Appropriate errors are thrown for: no camera permission, no microphone permission (for audio video), camera not found, camera busy, capture failed, mutex timeout
- [ ] `CameraProvider` is bound in Hilt DI module
- [ ] `FileOperationProvider` is extended with `createFileUri(locationId, path, mimeType)` method (interface + implementation + tests)
- [ ] Unit tests for `CameraProviderImpl` pass
- [ ] Linting passes on all new files

### Task 2.1: Create data models

**Definition of Done**: `CameraInfo.kt` and `CameraResolution.kt` data models are created in `data/model/`.

#### Action 2.1.1: Create `CameraInfo.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/data/model/CameraInfo.kt` (CREATE)
- **What**: Data class representing a camera device.
- **Content**:
  ```kotlin
  package com.danielealbano.androidremotecontrolmcp.data.model

  /**
   * Represents an available camera on the device.
   *
   * @property cameraId Unique identifier for the camera (from CameraX).
   * @property facing Camera facing direction: "front", "back", or "external".
   * @property hasFlash Whether the camera has a flash unit.
   * @property supportsPhoto Whether the camera supports photo capture.
   * @property supportsVideo Whether the camera supports video recording.
   */
  data class CameraInfo(
      val cameraId: String,
      val facing: String,
      val hasFlash: Boolean,
      val supportsPhoto: Boolean,
      val supportsVideo: Boolean,
  )
  ```

#### Action 2.1.2: Create `CameraResolution.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/data/model/CameraResolution.kt` (CREATE)
- **What**: Data classes representing photo and video resolutions.
- **Content**:
  ```kotlin
  package com.danielealbano.androidremotecontrolmcp.data.model

  /**
   * Represents a supported photo resolution for a camera.
   *
   * @property width Width in pixels.
   * @property height Height in pixels.
   * @property megapixels Approximate megapixels (width * height / 1_000_000, rounded to 1 decimal).
   * @property aspectRatio Human-readable aspect ratio (e.g., "16:9", "4:3").
   */
  data class PhotoResolution(
      val width: Int,
      val height: Int,
      val megapixels: Double,
      val aspectRatio: String,
  )

  /**
   * Represents a supported video resolution for a camera.
   *
   * @property width Width in pixels.
   * @property height Height in pixels.
   * @property aspectRatio Human-readable aspect ratio (e.g., "16:9", "4:3").
   * @property qualityLabel Human-readable quality label (e.g., "HD", "FHD", "UHD").
   */
  data class VideoResolution(
      val width: Int,
      val height: Int,
      val aspectRatio: String,
      val qualityLabel: String,
  )
  ```

### Task 2.2: Create `CameraProvider` interface

**Definition of Done**: `CameraProvider.kt` interface is created in `services/camera/`.

#### Action 2.2.1: Create `CameraProvider.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/camera/CameraProvider.kt` (CREATE)
- **What**: Interface defining all camera operations. Tools depend on this interface (not the implementation) for testability.
- **Content**:
  ```kotlin
  package com.danielealbano.androidremotecontrolmcp.services.camera

  import android.net.Uri
  import com.danielealbano.androidremotecontrolmcp.data.model.CameraInfo
  import com.danielealbano.androidremotecontrolmcp.data.model.PhotoResolution
  import com.danielealbano.androidremotecontrolmcp.data.model.ScreenshotData
  import com.danielealbano.androidremotecontrolmcp.data.model.VideoResolution

  /**
   * Abstracts access to device cameras for photo capture and video recording.
   *
   * Production implementation uses CameraX (Jetpack).
   * Tools use this interface to enable JVM-based testing with mock implementations.
   */
  interface CameraProvider {
      companion object {
          /** Default JPEG quality for photo capture. */
          const val DEFAULT_QUALITY = 80

          /** Default flash mode. */
          const val DEFAULT_FLASH_MODE = "auto"

          /** Maximum video recording duration in seconds. */
          const val MAX_VIDEO_DURATION_SECONDS = 30

          /** Default resolution target (720p) width. */
          const val DEFAULT_RESOLUTION_WIDTH = 1280

          /** Default resolution target (720p) height. */
          const val DEFAULT_RESOLUTION_HEIGHT = 720

          /** Maximum resolution for inline (base64) photo capture to prevent large responses. */
          const val MAX_INLINE_PHOTO_WIDTH = 1920

          /** Maximum resolution for inline (base64) photo capture to prevent large responses. */
          const val MAX_INLINE_PHOTO_HEIGHT = 1080

          /** Mutex timeout for photo operations in milliseconds. */
          const val PHOTO_OPERATION_TIMEOUT_MS = 45_000L

          /** Base mutex timeout for video operations in milliseconds (added to duration). */
          const val VIDEO_OPERATION_BASE_TIMEOUT_MS = 45_000L

          /** Valid flash modes. */
          val VALID_FLASH_MODES = setOf("off", "on", "auto")
      }

      /**
       * Lists all available cameras on the device.
       *
       * @return List of [CameraInfo] for each available camera.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if camera enumeration fails.
       */
      suspend fun listCameras(): List<CameraInfo>

      /**
       * Lists supported photo resolutions for a specific camera.
       *
       * @param cameraId Camera identifier from [listCameras].
       * @return List of [PhotoResolution] sorted by megapixels descending.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if camera not found or query fails.
       */
      suspend fun listPhotoResolutions(cameraId: String): List<PhotoResolution>

      /**
       * Lists supported video resolutions for a specific camera.
       *
       * @param cameraId Camera identifier from [listCameras].
       * @return List of [VideoResolution] sorted by width descending.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if camera not found or query fails.
       */
      suspend fun listVideoResolutions(cameraId: String): List<VideoResolution>

      /**
       * Captures a photo and returns it as base64-encoded JPEG.
       *
       * Resolution is capped at [MAX_INLINE_PHOTO_WIDTH]x[MAX_INLINE_PHOTO_HEIGHT]
       * (1920x1080) to prevent excessively large base64 JSON responses.
       * If a higher resolution is requested, it is clamped to this maximum.
       * Use [savePhoto] for full-resolution captures.
       *
       * @param cameraId Camera identifier from [listCameras].
       * @param width Requested width in pixels, or null for default (720p closest match). Capped at [MAX_INLINE_PHOTO_WIDTH].
       * @param height Requested height in pixels, or null for default (720p closest match). Capped at [MAX_INLINE_PHOTO_HEIGHT].
       * @param quality JPEG quality (1-100).
       * @param flashMode Flash mode: "off", "on", or "auto".
       * @return [ScreenshotData] containing the base64 JPEG data and dimensions.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if capture fails or operation times out.
       */
      suspend fun takePhoto(
          cameraId: String,
          width: Int? = null,
          height: Int? = null,
          quality: Int = DEFAULT_QUALITY,
          flashMode: String = DEFAULT_FLASH_MODE,
      ): ScreenshotData

      /**
       * Captures a photo and saves it to the specified URI.
       *
       * @param cameraId Camera identifier from [listCameras].
       * @param outputUri SAF document URI to write the photo to.
       * @param width Requested width in pixels, or null for default (720p closest match).
       * @param height Requested height in pixels, or null for default (720p closest match).
       * @param quality JPEG quality (1-100).
       * @param flashMode Flash mode: "off", "on", or "auto".
       * @return File size in bytes of the saved photo.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if capture, save fails, or operation times out.
       */
      suspend fun savePhoto(
          cameraId: String,
          outputUri: Uri,
          width: Int? = null,
          height: Int? = null,
          quality: Int = DEFAULT_QUALITY,
          flashMode: String = DEFAULT_FLASH_MODE,
      ): Long

      /**
       * Records a video and saves it to the specified URI.
       *
       * @param cameraId Camera identifier from [listCameras].
       * @param outputUri SAF document URI to write the video to.
       * @param durationSeconds Recording duration in seconds (1 to [MAX_VIDEO_DURATION_SECONDS]).
       * @param width Requested width in pixels, or null for default (720p closest match).
       * @param height Requested height in pixels, or null for default (720p closest match).
       * @param audio Whether to record audio (requires RECORD_AUDIO permission).
       * @param flashMode Flash mode: "off", "on", or "auto" (torch mode for video).
       * @return [VideoRecordingResult] containing file size and thumbnail data.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.PermissionDenied if camera (or microphone when audio=true) permission not granted.
       * @throws com.danielealbano.androidremotecontrolmcp.mcp.McpToolException.ActionFailed if recording fails or operation times out.
       */
      suspend fun saveVideo(
          cameraId: String,
          outputUri: Uri,
          durationSeconds: Int,
          width: Int? = null,
          height: Int? = null,
          audio: Boolean = true,
          flashMode: String = DEFAULT_FLASH_MODE,
      ): VideoRecordingResult

      /**
       * Checks whether the CAMERA runtime permission is granted.
       */
      fun isCameraPermissionGranted(): Boolean

      /**
       * Checks whether the RECORD_AUDIO runtime permission is granted.
       */
      fun isMicrophonePermissionGranted(): Boolean
  }

  /**
   * Result of a video recording operation.
   *
   * @property fileSizeBytes Size of the recorded video file in bytes.
   * @property durationMs Actual recording duration in milliseconds.
   * @property thumbnailData Base64-encoded JPEG thumbnail (first frame).
   * @property thumbnailWidth Thumbnail width in pixels.
   * @property thumbnailHeight Thumbnail height in pixels.
   */
  data class VideoRecordingResult(
      val fileSizeBytes: Long,
      val durationMs: Long,
      val thumbnailData: String,
      val thumbnailWidth: Int,
      val thumbnailHeight: Int,
  )
  ```

### Task 2.3: Create `ServiceLifecycleOwner`

**Definition of Done**: `ServiceLifecycleOwner.kt` is created, providing a `LifecycleOwner` implementation usable from a service context for CameraX binding.

#### Action 2.3.1: Create `ServiceLifecycleOwner.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/camera/ServiceLifecycleOwner.kt` (CREATE)
- **What**: A custom `LifecycleOwner` that CameraX can bind to from a non-Activity context. Manually manages lifecycle states (CREATED → STARTED → RESUMED for camera operations, then back to DESTROYED).
- **Content**:
  ```kotlin
  package com.danielealbano.androidremotecontrolmcp.services.camera

  import androidx.lifecycle.Lifecycle
  import androidx.lifecycle.LifecycleOwner
  import androidx.lifecycle.LifecycleRegistry

  /**
   * A [LifecycleOwner] usable from a Service context for CameraX binding.
   *
   * CameraX requires a [LifecycleOwner] to manage camera lifecycle.
   * Since [android.app.Service] does not implement [LifecycleOwner],
   * this class provides a manually controlled lifecycle.
   *
   * Usage:
   * 1. Call [start] before binding CameraX use cases
   * 2. Use the camera
   * 3. Call [stop] to unbind and release camera resources
   */
  class ServiceLifecycleOwner : LifecycleOwner {
      private val lifecycleRegistry = LifecycleRegistry(this)

      override val lifecycle: Lifecycle
          get() = lifecycleRegistry

      /**
       * Transitions lifecycle through INITIALIZED → CREATED → STARTED → RESUMED,
       * enabling CameraX use cases.
       */
      fun start() {
          lifecycleRegistry.currentState = Lifecycle.State.CREATED
          lifecycleRegistry.currentState = Lifecycle.State.STARTED
          lifecycleRegistry.currentState = Lifecycle.State.RESUMED
      }

      /**
       * Transitions lifecycle through RESUMED → STARTED → CREATED → DESTROYED,
       * properly releasing CameraX resources. Must not skip states to ensure
       * CameraX lifecycle observers receive all expected callbacks.
       */
      fun stop() {
          lifecycleRegistry.currentState = Lifecycle.State.STARTED
          lifecycleRegistry.currentState = Lifecycle.State.CREATED
          lifecycleRegistry.currentState = Lifecycle.State.DESTROYED
      }
  }
  ```

### Task 2.4: Unit tests for `ServiceLifecycleOwner`

**Definition of Done**: Unit tests verify that `ServiceLifecycleOwner` transitions lifecycle states correctly.

#### Action 2.4.1: Create `ServiceLifecycleOwnerTest.kt`

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/services/camera/ServiceLifecycleOwnerTest.kt` (CREATE)
- **What**: Unit tests for `ServiceLifecycleOwner` using JUnit 5. No mocks needed — `LifecycleRegistry` is available in test scope via the transitive dependency from `camera-lifecycle` → `lifecycle-common`. If `LifecycleRegistry` is not found on the test classpath, add `testImplementation(libs.lifecycle.runtime.testing)` to `app/build.gradle.kts`.
- **Tests to include**:
  - `initial state is INITIALIZED`
  - `start transitions to RESUMED`
  - `stop after start transitions to DESTROYED`
  - `start transitions through CREATED then STARTED then RESUMED in order`
  - `stop transitions through STARTED then CREATED then DESTROYED in order`
  - `calling stop without start does not crash` (guard against misuse)

### Task 2.5: Create `CameraProviderImpl`

**Definition of Done**: `CameraProviderImpl.kt` is created with full CameraX-based implementation of all `CameraProvider` methods.

#### Action 2.5.1: Create `CameraProviderImpl.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/camera/CameraProviderImpl.kt` (CREATE)
- **What**: CameraX-based implementation of `CameraProvider`. Uses `ProcessCameraProvider` for camera access, `ImageCapture` for photos, `VideoCapture<Recorder>` for video, and `MediaMetadataRetriever` for thumbnail extraction. All camera operations are serialized via `Mutex`.
- **Key implementation details**:
  - Inject `@ApplicationContext context: Context` and `ScreenshotEncoder` via Hilt
  - Use `Mutex` for serialized camera access with timeout via `withTimeout(timeoutMs) { cameraMutex.withLock { ... } }`. Timeout values: 45_000ms for photo operations, `(45 + durationSeconds) * 1000` ms for video operations. If timeout fires, throw `McpToolException.ActionFailed("Camera operation timed out")`
  - **CRITICAL**: Create a **new** `ServiceLifecycleOwner()` instance for EACH camera operation. Once a `LifecycleRegistry` reaches DESTROYED, it cannot be reused — `LifecycleRegistry` throws `IllegalStateException` if you try to move from DESTROYED to any other state. Do NOT store the lifecycle owner as a field; create it locally within each operation's `withTimeout { cameraMutex.withLock { ... } }` block
  - Use `ProcessCameraProvider.getInstance(context)` to get camera provider
  - Camera enumeration: use `ProcessCameraProvider.availableCameraInfos` to get ALL cameras (front, back, external, multiple rear cameras on modern devices). Do NOT use `DEFAULT_FRONT_CAMERA`/`DEFAULT_BACK_CAMERA` selectors as they only find one front and one back camera, missing ultra-wide, telephoto, macro, and external cameras
  - Camera ID mapping: use `Camera2CameraInfo.from(cameraInfo).cameraId` to get the stable hardware camera ID. Determine facing from `Camera2CameraInfo.from(cameraInfo).getCameraCharacteristic(CameraCharacteristics.LENS_FACING)` mapping to "front", "back", or "external"
  - Photo resolution listing: use `Camera2CameraInfo.from(cameraInfo)` to get `CameraCharacteristics`, then query `SCALER_STREAM_CONFIGURATION_MAP.getOutputSizes(ImageFormat.JPEG)` for supported photo capture sizes. Do NOT use `ImageAnalysis` (that returns analysis frame sizes, not capture sizes)
  - Video resolution listing: use `QualitySelector` and `Recorder.getVideoCapabilities(cameraInfo)` to query supported qualities
  - Photo capture (inline/base64): configure `ImageCapture` with `ResolutionSelector` targeting requested resolution (or 720p default), **cap at 1920x1080 max** to prevent excessively large JSON responses, set flash mode, use `takePicture()` with in-memory callback, encode to JPEG base64 via `ScreenshotEncoder`
  - Photo capture (save): configure `ImageCapture` with `ResolutionSelector` targeting requested resolution (or 720p default, **no max cap** — user controls storage), set flash mode, open an `OutputStream` via `contentResolver.openOutputStream(outputUri)!!`, create `ImageCapture.OutputFileOptions.Builder(outputStream)`, call `takePicture()`. **The `OutputStream` MUST be closed in a `finally` block after the photo is saved** (even on error paths). Note: the `Builder(ContentResolver, Uri, ContentValues)` overload is for MediaStore collection URIs only and does NOT work with SAF document URIs
  - Video recording: configure `Recorder` with `QualitySelector` for requested resolution, create `VideoCapture<Recorder>`, open `ParcelFileDescriptor` via `contentResolver.openFileDescriptor(outputUri, "w")`, create `FileDescriptorOutputOptions`, start recording, wait for `durationSeconds`, stop recording. **The `ParcelFileDescriptor` MUST be closed in a `finally` block after recording completes** (even on error paths)
  - File size retrieval (after photo save or video recording): use `context.contentResolver.openFileDescriptor(outputUri, "r")?.use { it.statSize } ?: 0L` to get file size in bytes. This is needed for both `savePhoto()` (returns `Long`) and `VideoRecordingResult.fileSizeBytes`
  - Video thumbnail: use `MediaMetadataRetriever` with `setDataSource(context, outputUri)` then `getFrameAtTime(0)` to extract first frame, encode via `ScreenshotEncoder`, resize to 720px max. Close `MediaMetadataRetriever` in a `finally` block via `.close()` (or `.release()` for API < 29)
  - Permission checks: `ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)` and `Manifest.permission.RECORD_AUDIO`
  - Error handling: throw `McpToolException.PermissionDenied` for missing permissions, `McpToolException.ActionFailed` for camera/capture failures
  - Flash mode mapping: `"off"` → `ImageCapture.FLASH_MODE_OFF`, `"on"` → `ImageCapture.FLASH_MODE_ON`, `"auto"` → `ImageCapture.FLASH_MODE_AUTO`; for video, `"on"` / `"auto"` → enable torch via `Camera.cameraControl.enableTorch(true)`
  - All operations run on `Dispatchers.Main` for CameraX binding (CameraX requires main thread for lifecycle binding), with encoding on `Dispatchers.Default`
  - Log tag: `"MCP:CameraProvider"`

> **Note**: This is the most complex file. The implementor must ensure proper resource cleanup in all paths including error paths using `try/finally` blocks. Specific resources to clean up: (1) `ServiceLifecycleOwner.stop()` — always call in finally; this transitions lifecycle to DESTROYED which causes CameraX to automatically unbind all use cases (no manual `ProcessCameraProvider.unbindAll()` call needed), (2) `Bitmap.recycle()` — after encoding to base64, (3) `OutputStream.close()` — after photo save (opened via `contentResolver.openOutputStream()`), (4) `ParcelFileDescriptor.close()` — after video recording, (5) `MediaMetadataRetriever.close()` — after thumbnail extraction.

### Task 2.6: Bind CameraProvider in Hilt DI module

**Definition of Done**: `CameraProviderImpl` is bound to `CameraProvider` interface in `AppModule.kt`.

#### Action 2.6.1: Add import and binding to `AppModule.kt`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/di/AppModule.kt`
- **What**: Add import for `CameraProvider` and `CameraProviderImpl`, add `@Binds @Singleton` binding in `ServiceModule`.
- **Change**: Add imports:
  ```kotlin
  import com.danielealbano.androidremotecontrolmcp.services.camera.CameraProvider
  import com.danielealbano.androidremotecontrolmcp.services.camera.CameraProviderImpl
  ```
  Add binding in `ServiceModule` (after `bindAppManager`):
  ```kotlin
  @Binds
  @Singleton
  abstract fun bindCameraProvider(impl: CameraProviderImpl): CameraProvider
  ```

### Task 2.7: Extend `FileOperationProvider` with `createFileUri`

**Definition of Done**: `FileOperationProvider` interface has a new `createFileUri(locationId, path, mimeType)` method that creates a document in a SAF storage location and returns its `Uri`. Implementation added to `FileOperationProviderImpl`. Unit test added for the new method.

#### Action 2.7.1: Add `createFileUri` to `FileOperationProvider` interface

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/storage/FileOperationProvider.kt`
- **What**: Add `import android.net.Uri` and a new method to the interface that the `save_camera_photo` and `save_camera_video` tools will use to create a file URI that CameraX can write to.
- **Change**: Add import `import android.net.Uri` at the top of the file. Add method after `deleteFile`:
  ```kotlin
  /**
   * Creates a new file in the specified storage location and returns its URI.
   * Creates parent directories if they don't exist. If a file at the given
   * path already exists, it is returned as-is (no overwrite of content).
   *
   * This is intended for use cases where an external component (e.g., CameraX)
   * needs a URI to write to directly, rather than writing content through
   * this provider.
   *
   * @param locationId The authorized storage location identifier.
   * @param path Relative path to the file.
   * @param mimeType The MIME type for the new file (e.g., "image/jpeg", "video/mp4").
   *        Note: the actual MIME type used for document creation is inferred from the
   *        file extension in [path] via the internal `guessMimeType` method.
   * @return The [Uri] for the created file.
   */
  suspend fun createFileUri(
      locationId: String,
      path: String,
      mimeType: String,
  ): Uri
  ```

#### Action 2.7.2: Implement `createFileUri` in `FileOperationProviderImpl`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/storage/FileOperationProviderImpl.kt`
- **What**: Implement `createFileUri` reusing the existing `ensureParentDirectoriesAndCreateFile` internal method, which already creates parent directories and the file. Return the URI from the created `DocumentFile`.
- **Change**: Add implementation:
  ```kotlin
  override suspend fun createFileUri(
      locationId: String,
      path: String,
      mimeType: String,
  ): Uri {
      checkAuthorization(locationId)
      checkWritePermission(locationId)
      val documentFile = ensureParentDirectoriesAndCreateFile(locationId, path)
      return documentFile.uri
  }
  ```
- **Note**: The existing `ensureParentDirectoriesAndCreateFile(locationId, path)` takes 2 arguments (no `mimeType`). It infers the MIME type from the file extension via the internal `guessMimeType(fileName)` method. This already maps `.jpg`/`.jpeg` → `image/jpeg` and `.mp4` → `video/mp4` correctly. The `mimeType` parameter on `createFileUri` is accepted for API clarity but the actual MIME type used for `DocumentFile.createFile()` comes from the extension. If the extension doesn't match the MIME type, the caller should use the correct extension in the `path` (e.g., `photo.jpg`, `video.mp4`).

#### Action 2.7.3: Add unit test for `createFileUri`

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/services/storage/FileOperationProviderTest.kt` (MODIFY — existing file)
- **What**: Add test cases for the new `createFileUri` method to the existing test file.
- **Tests to include**:
  - `createFileUri returns valid URI for authorized location with write permission`
  - `createFileUri throws PermissionDenied for unauthorized location`
  - `createFileUri throws PermissionDenied for read-only location`
  - `createFileUri creates parent directories when they don't exist`

### Task 2.8: Create unit tests for CameraProviderImpl

**Definition of Done**: Unit tests verify permission checks, camera enumeration, photo capture, and video recording logic.

#### Action 2.8.1: Create `CameraProviderImplTest.kt`

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/services/camera/CameraProviderImplTest.kt` (CREATE)
- **What**: Unit tests for `CameraProviderImpl` using JUnit 5 + MockK. Mock `ProcessCameraProvider`, `ImageCapture`, `VideoCapture`, `Context`, `ScreenshotEncoder`.
- **Tests to include**:
  - `listCameras returns available cameras with correct facing`
  - `listCameras throws PermissionDenied when camera permission not granted`
  - `listCameras returns empty list when no cameras available`
  - `listPhotoResolutions returns sorted resolutions for valid camera`
  - `listPhotoResolutions throws ActionFailed for invalid camera ID`
  - `listVideoResolutions returns sorted resolutions for valid camera`
  - `listVideoResolutions throws ActionFailed for invalid camera ID`
  - `takePhoto returns base64 JPEG data for valid camera`
  - `takePhoto throws PermissionDenied when camera permission not granted`
  - `takePhoto applies flash mode correctly (off, on, auto)`
  - `takePhoto caps resolution at 1920x1080 for inline return`
  - `takePhoto uses default 720p resolution when none specified`
  - `savePhoto writes to output URI`
  - `savePhoto throws PermissionDenied when camera permission not granted`
  - `savePhoto does not cap resolution (no 1920x1080 limit)`
  - `saveVideo records for specified duration`
  - `saveVideo throws PermissionDenied when camera permission not granted`
  - `saveVideo throws PermissionDenied when audio enabled but microphone permission not granted`
  - `saveVideo throws InvalidParams when duration exceeds 30 seconds`
  - `saveVideo throws InvalidParams when duration is less than 1`
  - `saveVideo returns thumbnail with correct dimensions`
  - `saveVideo records without audio when audio is false`
  - `saveVideo uses torch for flash on and auto modes`
  - `camera operation throws ActionFailed on mutex timeout`
  - `concurrent camera operations are serialized via mutex`
  - `isCameraPermissionGranted returns correct state`
  - `isMicrophonePermissionGranted returns correct state`

### Task 2.9: Run lint and tests

**Definition of Done**: All new files pass linting and all unit tests pass.

#### Action 2.9.1: Run linting on new files

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No new warnings or errors

#### Action 2.9.2: Run unit tests

- **Command**: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.services.camera.*" --tests "com.danielealbano.androidremotecontrolmcp.services.storage.FileOperationProviderTest"`
- **Expected**: All tests pass (includes both camera service tests and the new `createFileUri` tests)

---

## User Story 3: MCP Camera Tool Handlers

**Goal**: Create the 6 MCP tool handlers and the registration function for camera tools, following the existing tool handler patterns.

### Acceptance Criteria
- [ ] `CameraTools.kt` is created with 6 handler classes: `ListCamerasHandler`, `ListCameraPhotoResolutionsHandler`, `ListCameraVideoResolutionsHandler`, `TakeCameraPhotoHandler`, `SaveCameraPhotoHandler`, `SaveCameraVideoHandler`
- [ ] Each handler follows the existing pattern: `@Inject constructor`, `suspend fun execute(arguments: JsonObject?): CallToolResult`, `fun register(server: Server, toolNamePrefix: String)`, `companion object { const val TOOL_NAME = "..." }`
- [ ] `registerCameraTools()` top-level function is created
- [ ] `list_cameras` returns JSON array of camera info objects
- [ ] `list_camera_photo_resolutions` accepts `camera_id`, returns JSON array of photo resolutions
- [ ] `list_camera_video_resolutions` accepts `camera_id`, returns JSON array of video resolutions
- [ ] `take_camera_photo` accepts `camera_id`, optional `resolution`, `quality`, `flash_mode`; returns `ImageContent` (base64 JPEG)
- [ ] `save_camera_photo` accepts `camera_id`, `location_id`, `path`, optional `resolution`, `quality`, `flash_mode`; delegates write permission check to `FileOperationProvider.createFileUri()`; returns `TextContent`
- [ ] `save_camera_video` accepts `camera_id`, `location_id`, `path`, `duration`, optional `resolution`, `audio`, `flash_mode`; delegates write permission check to `FileOperationProvider.createFileUri()`; returns `TextContent` + `ImageContent` thumbnail; description states max 30 seconds
- [ ] All parameter validation uses `McpToolUtils` helper functions
- [ ] All errors use `McpToolException` subtypes
- [ ] `McpIntegrationTestHelper.MockDependencies` includes `cameraProvider` (required before integration tests)
- [ ] `McpIntegrationTestHelper.createMockDependencies()` creates mock `CameraProvider`
- [ ] `McpIntegrationTestHelper.registerAllTools()` calls `registerCameraTools()`
- [ ] Unit tests for all 6 handlers pass
- [ ] Integration tests pass
- [ ] Linting passes

### Task 3.1: Create `CameraTools.kt`

**Definition of Done**: All 6 tool handlers and the `registerCameraTools()` function are implemented.

#### Action 3.1.1: Create `CameraTools.kt` with all handlers

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/tools/CameraTools.kt` (CREATE)
- **What**: 6 MCP tool handler classes + registration function.
- **Handler details**:

**`ListCamerasHandler`**:
- TOOL_NAME: `"list_cameras"`
- Dependencies: `CameraProvider`
- Parameters: none
- Execute: call `cameraProvider.listCameras()`, build JSON array with objects `{camera_id, facing, has_flash, supports_photo, supports_video}`
- Description: `"Lists all available cameras on the device with their capabilities (facing direction, flash support, photo/video support)."`

**`ListCameraPhotoResolutionsHandler`**:
- TOOL_NAME: `"list_camera_photo_resolutions"`
- Dependencies: `CameraProvider`
- Parameters: `camera_id` (required string)
- Execute: call `cameraProvider.listPhotoResolutions(cameraId)`, build JSON array with objects `{width, height, megapixels, aspect_ratio}`
- Description: `"Lists supported photo resolutions for a specific camera. Use the camera_id from list_cameras."`

**`ListCameraVideoResolutionsHandler`**:
- TOOL_NAME: `"list_camera_video_resolutions"`
- Dependencies: `CameraProvider`
- Parameters: `camera_id` (required string)
- Execute: call `cameraProvider.listVideoResolutions(cameraId)`, build JSON array with objects `{width, height, aspect_ratio, quality_label}`
- Description: `"Lists supported video resolutions for a specific camera. Use the camera_id from list_cameras."`

**`TakeCameraPhotoHandler`**:
- TOOL_NAME: `"take_camera_photo"`
- Dependencies: `CameraProvider`
- Parameters:
  - `camera_id` (required string)
  - `resolution` (optional string, format `"WIDTHxHEIGHT"` e.g. `"1280x720"`, default: 720p closest match)
  - `quality` (optional int, 1-100, default 80)
  - `flash_mode` (optional string: `"off"`, `"on"`, `"auto"`, default `"auto"`)
- Execute: parse resolution if provided (split on "x", validate both are positive ints), validate quality range, validate flash_mode in valid set, call `cameraProvider.takePhoto(...)`, return `McpToolUtils.imageResult(data, "image/jpeg")`
- Description: `"Captures a photo from the specified camera and returns it as a base64-encoded JPEG image. Default resolution is 720p (closest available match). Maximum resolution is capped at 1920x1080 to prevent excessively large responses. Use save_camera_photo for higher resolutions."`

**`SaveCameraPhotoHandler`**:
- TOOL_NAME: `"save_camera_photo"`
- Dependencies: `CameraProvider`, `FileOperationProvider`
- Parameters:
  - `camera_id` (required string)
  - `location_id` (required string)
  - `path` (required string)
  - `resolution` (optional string, format `"WIDTHxHEIGHT"`, default: 720p closest match)
  - `quality` (optional int, 1-100, default 80)
  - `flash_mode` (optional string: `"off"`, `"on"`, `"auto"`, default `"auto"`)
- Execute:
  1. Validate parameters (camera_id, location_id, path required; parse resolution if provided; validate quality, flash_mode)
  2. Create output URI via `fileOperationProvider.createFileUri(locationId, path, "image/jpeg")` — this internally checks authorization and write permission, throwing `McpToolException.PermissionDenied` if denied (consistent with existing `WriteFileHandler` pattern)
  3. Call `cameraProvider.savePhoto(cameraId, outputUri, width, height, quality, flashMode)`
  4. Return `McpToolUtils.textResult("Photo saved successfully: $path ($fileSizeBytes bytes)")`
- Description: `"Captures a photo from the specified camera and saves it to a storage location. Requires write permission on the storage location. Default resolution is 720p (closest available match)."`

**`SaveCameraVideoHandler`**:
- TOOL_NAME: `"save_camera_video"`
- Dependencies: `CameraProvider`, `FileOperationProvider`
- Parameters:
  - `camera_id` (required string)
  - `location_id` (required string)
  - `path` (required string)
  - `duration` (required int, 1-30 seconds)
  - `resolution` (optional string, format `"WIDTHxHEIGHT"`, default: 720p closest match)
  - `audio` (optional boolean, default true)
  - `flash_mode` (optional string: `"off"`, `"on"`, `"auto"`, default `"auto"`)
- Execute:
  1. Validate all parameters (camera_id, location_id, path, duration required; validate `duration` in range [1, 30]; parse resolution if provided; validate audio, flash_mode)
  2. Create output URI via `fileOperationProvider.createFileUri(locationId, path, "video/mp4")` — this internally checks authorization and write permission (consistent with existing `WriteFileHandler` pattern)
  3. Call `cameraProvider.saveVideo(cameraId, outputUri, duration, width, height, audio, flashMode)`
  4. Return `McpToolUtils.textAndImageResult(text, thumbnailData, "image/jpeg")` where text = `"Video saved successfully: $path ($fileSizeBytes bytes, ${durationMs}ms)"`
- Description: `"Records a video from the specified camera and saves it to a storage location. Maximum duration is 30 seconds. Includes audio by default. Requires write permission on the storage location. Returns a thumbnail of the first frame. Default resolution is 720p (closest available match)."`

**`registerCameraTools()`**:
- Signature: `fun registerCameraTools(server: Server, cameraProvider: CameraProvider, fileOperationProvider: FileOperationProvider, toolNamePrefix: String)`
- Creates all 6 handlers and calls `register()` on each
- `ListCamerasHandler`, `ListCameraPhotoResolutionsHandler`, `ListCameraVideoResolutionsHandler`, `TakeCameraPhotoHandler` receive only `cameraProvider`
- `SaveCameraPhotoHandler`, `SaveCameraVideoHandler` receive `cameraProvider` and `fileOperationProvider`

> **Note on resolution parameter**: The `resolution` parameter uses `"WIDTHxHEIGHT"` format (e.g., `"1280x720"`) as a single string. This is simpler than separate width/height params. The handler parses it and passes width/height to `CameraProvider`. If not provided, `null` is passed for width/height and `CameraProvider` uses its 720p default.
>
> **Note on nullable optional string**: `McpToolUtils.optionalString()` always returns a non-null `String` (it has a `default: String` parameter). Since the `resolution` parameter must be `null` when not provided (to signal "use default"), handlers MUST NOT use `optionalString`. Instead, use direct JSON access: `val resolutionStr: String? = (arguments?.get("resolution") as? JsonPrimitive)?.takeIf { it.isString }?.content`. If the key is absent, `resolutionStr` is `null`. If present, parse with `split("x")` and validate. This same pattern applies to any optional parameter that needs a `null` default rather than a string default.

> **Note on save tool file creation**: The save tools use `FileOperationProvider.createFileUri(locationId, path, mimeType)` to create the output document URI that CameraX writes to. This method is added in Task 2.7 of User Story 2 and must be implemented before this user story.

### Task 3.2: Create unit tests for camera tool handlers

**Definition of Done**: Unit tests verify parameter validation, permission checks, success paths, and error handling for all 6 handlers.

#### Action 3.2.1: Create `CameraToolsTest.kt`

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/mcp/tools/CameraToolsTest.kt` (CREATE)
- **What**: Unit tests for all 6 camera tool handlers using JUnit 5 + MockK. Mock `CameraProvider` and `FileOperationProvider` (save handlers only need these two dependencies; `StorageLocationProvider` is NOT used since permission checking is delegated to `FileOperationProvider.createFileUri()`).
- **Tests to include** (grouped by handler):

  **ListCamerasHandler:**
  - `list_cameras returns camera info as JSON array`
  - `list_cameras returns empty array when no cameras available`
  - `list_cameras propagates PermissionDenied from CameraProvider`

  **ListCameraPhotoResolutionsHandler:**
  - `list_camera_photo_resolutions returns resolutions for valid camera`
  - `list_camera_photo_resolutions throws InvalidParams when camera_id missing`
  - `list_camera_photo_resolutions propagates ActionFailed for invalid camera`

  **ListCameraVideoResolutionsHandler:**
  - `list_camera_video_resolutions returns resolutions for valid camera`
  - `list_camera_video_resolutions throws InvalidParams when camera_id missing`

  **TakeCameraPhotoHandler:**
  - `take_camera_photo returns ImageContent with base64 data`
  - `take_camera_photo with custom resolution parses WIDTHxHEIGHT correctly`
  - `take_camera_photo with invalid resolution format throws InvalidParams` (e.g. "abc", "1280", "1280x", "x720", "1280xabc")
  - `take_camera_photo with negative resolution values throws InvalidParams`
  - `take_camera_photo with zero resolution values throws InvalidParams`
  - `take_camera_photo with quality 0 throws InvalidParams`
  - `take_camera_photo with quality 101 throws InvalidParams`
  - `take_camera_photo with quality 1 succeeds (boundary)`
  - `take_camera_photo with quality 100 succeeds (boundary)`
  - `take_camera_photo with invalid flash_mode throws InvalidParams`
  - `take_camera_photo without optional params uses defaults`
  - `take_camera_photo throws InvalidParams when camera_id missing`

  **SaveCameraPhotoHandler:**
  - `save_camera_photo saves to storage and returns success text`
  - `save_camera_photo throws InvalidParams when camera_id missing`
  - `save_camera_photo throws InvalidParams when location_id missing`
  - `save_camera_photo throws InvalidParams when path missing`
  - `save_camera_photo propagates PermissionDenied from createFileUri when location unauthorized`
  - `save_camera_photo propagates PermissionDenied from createFileUri when write not allowed`
  - `save_camera_photo calls createFileUri with image/jpeg mime type`

  **SaveCameraVideoHandler:**
  - `save_camera_video saves to storage and returns text with thumbnail`
  - `save_camera_video with duration 1 succeeds (boundary)`
  - `save_camera_video with duration 30 succeeds (boundary)`
  - `save_camera_video with duration 0 throws InvalidParams`
  - `save_camera_video with duration 31 throws InvalidParams`
  - `save_camera_video with negative duration throws InvalidParams`
  - `save_camera_video throws InvalidParams when camera_id missing`
  - `save_camera_video throws InvalidParams when location_id missing`
  - `save_camera_video throws InvalidParams when path missing`
  - `save_camera_video throws InvalidParams when duration missing`
  - `save_camera_video propagates PermissionDenied from createFileUri when location unauthorized`
  - `save_camera_video propagates PermissionDenied from createFileUri when write not allowed`
  - `save_camera_video with audio false calls saveVideo with audio=false`
  - `save_camera_video calls createFileUri with video/mp4 mime type`

### Task 3.3: Update `McpIntegrationTestHelper` for camera tools

**Definition of Done**: Integration test helper includes `CameraProvider` mock and registers camera tools. This MUST be done before creating integration tests (Task 3.4).

#### Action 3.3.1: Add CameraProvider to MockDependencies

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/integration/McpIntegrationTestHelper.kt`
- **What**: Add `cameraProvider` field to `MockDependencies` data class, add import, update `createMockDependencies()` and `registerAllTools()`.
- **Changes**:
  - Add import:
    ```kotlin
    import com.danielealbano.androidremotecontrolmcp.services.camera.CameraProvider
    import com.danielealbano.androidremotecontrolmcp.mcp.tools.registerCameraTools
    ```
  - Add field to `MockDependencies`:
    ```kotlin
    val cameraProvider: CameraProvider,
    ```
  - Add to `createMockDependencies()`:
    ```kotlin
    cameraProvider = mockk(relaxed = true),
    ```
  - Add to `registerAllTools()` (after `registerAppManagementTools`):
    ```kotlin
    registerCameraTools(server, deps.cameraProvider, deps.fileOperationProvider, toolNamePrefix)
    ```

### Task 3.4: Create integration tests for camera tools

**Definition of Done**: Integration tests verify the full HTTP stack (auth, routing, tool dispatch, response format) for all 6 camera tools.

#### Action 3.4.1: Create `CameraToolsIntegrationTest.kt`

- **File**: `app/src/test/kotlin/com/danielealbano/androidremotecontrolmcp/integration/CameraToolsIntegrationTest.kt` (CREATE)
- **What**: Integration tests using `McpIntegrationTestHelper.withTestApplication()` with mock CameraProvider. Tests go through the full HTTP → SDK → tool dispatch → response pipeline.
- **Tests to include**:
  - `list_cameras returns JSON array through MCP protocol`
  - `list_cameras with no cameras returns empty array through MCP protocol`
  - `list_camera_photo_resolutions returns resolutions through MCP protocol`
  - `list_camera_photo_resolutions with invalid camera_id returns error through MCP protocol`
  - `list_camera_video_resolutions returns resolutions through MCP protocol`
  - `list_camera_video_resolutions with invalid camera_id returns error through MCP protocol`
  - `take_camera_photo returns ImageContent through MCP protocol`
  - `take_camera_photo with invalid resolution returns error through MCP protocol`
  - `take_camera_photo with missing camera_id returns error through MCP protocol`
  - `save_camera_photo returns success text through MCP protocol`
  - `save_camera_photo with write not allowed returns error through MCP protocol`
  - `save_camera_video returns text and image content through MCP protocol`
  - `save_camera_video with duration exceeding 30 returns error through MCP protocol`
  - `save_camera_video with write not allowed returns error through MCP protocol`
  - `camera tool with missing camera permission returns error through MCP protocol`

### Task 3.5: Run lint and tests

**Definition of Done**: All files pass linting and all tests pass.

#### Action 3.5.1: Run linting

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No new warnings or errors

#### Action 3.5.2: Run unit tests for camera tools

- **Command**: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.mcp.tools.CameraToolsTest"`
- **Expected**: All tests pass

#### Action 3.5.3: Run integration tests for camera tools

- **Command**: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.integration.CameraToolsIntegrationTest"`
- **Expected**: All tests pass

---

## User Story 4: Wire Camera Tools into MCP Server

**Goal**: Register camera tools with the MCP server production code.

> **Note**: The integration test helper (`McpIntegrationTestHelper`) was already updated in US3 Task 3.3 (required before integration tests could run). This user story only wires the production `McpServerService`.

### Acceptance Criteria
- [ ] `McpServerService` injects `CameraProvider`
- [ ] `McpServerService.registerAllTools()` calls `registerCameraTools()`
- [ ] All existing tests still pass (no regressions)
- [ ] Linting passes

### Task 4.1: Update `McpServerService`

**Definition of Done**: `McpServerService` injects `CameraProvider` and registers camera tools.

#### Action 4.1.1: Add CameraProvider injection to `McpServerService`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/McpServerService.kt`
- **What**: Add `@Inject lateinit var cameraProvider: CameraProvider` field and import.
- **Change**: Add import:
  ```kotlin
  import com.danielealbano.androidremotecontrolmcp.services.camera.CameraProvider
  ```
  Add field after `typeInputController`:
  ```kotlin
  @Inject lateinit var cameraProvider: CameraProvider
  ```

#### Action 4.1.2: Add `registerCameraTools` import and call

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/services/mcp/McpServerService.kt`
- **What**: Add import for `registerCameraTools` and call it in `registerAllTools()`.
- **Change**: Add import:
  ```kotlin
  import com.danielealbano.androidremotecontrolmcp.mcp.tools.registerCameraTools
  ```
  Add call at end of `registerAllTools()` (after `registerAppManagementTools`):
  ```kotlin
  registerCameraTools(server, cameraProvider, fileOperationProvider, toolNamePrefix)
  ```

### Task 4.2: Run all tests to verify no regressions

**Definition of Done**: All existing tests pass, no regressions.

#### Action 4.2.1: Run full test suite

- **Command**: `./gradlew :app:test`
- **Expected**: All tests pass (including existing tests — no regressions)

#### Action 4.2.2: Run linting

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No new warnings or errors

---

## User Story 5: UI — Camera and Microphone Permission Status

**Goal**: Add camera and microphone permission status to the Permissions section in the UI, and add the ability to request these permissions.

### Acceptance Criteria
- [ ] `PermissionUtils` has `isCameraPermissionGranted(context)` and `isMicrophonePermissionGranted(context)` methods
- [ ] `MainViewModel` exposes `isCameraPermissionGranted` and `isMicrophonePermissionGranted` as `StateFlow<Boolean>`
- [ ] `MainViewModel.refreshPermissionStatus()` checks camera and microphone permissions
- [ ] `PermissionsSection` composable displays camera and microphone permission rows
- [ ] `HomeScreen` accepts `onRequestCameraPermission` and `onRequestMicrophonePermission` callbacks and passes to `PermissionsSection`
- [ ] `MainActivity` creates `cameraPermissionLauncher` and `microphonePermissionLauncher` (following existing notification pattern) and passes callbacks to `HomeScreen`
- [ ] Camera permission row shows "Camera" label with enable/granted status
- [ ] Microphone permission row shows "Microphone" label with enable/granted status
- [ ] String resources are added for camera and microphone permission labels
- [ ] Linting passes on all modified files

### Task 5.1: Add permission check methods to `PermissionUtils`

**Definition of Done**: `PermissionUtils` has camera and microphone permission check methods.

#### Action 5.1.1: Add `isCameraPermissionGranted` and `isMicrophonePermissionGranted`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/utils/PermissionUtils.kt`
- **What**: Add two new functions after `isNotificationPermissionGranted()`.
- **Change**: Add:
  ```kotlin
  /**
   * Checks whether the `CAMERA` runtime permission is granted.
   *
   * @param context Application context.
   * @return `true` if camera permission is granted, `false` otherwise.
   */
  fun isCameraPermissionGranted(context: Context): Boolean =
      ContextCompat.checkSelfPermission(
          context,
          Manifest.permission.CAMERA,
      ) == PackageManager.PERMISSION_GRANTED

  /**
   * Checks whether the `RECORD_AUDIO` runtime permission is granted.
   *
   * @param context Application context.
   * @return `true` if microphone permission is granted, `false` otherwise.
   */
  fun isMicrophonePermissionGranted(context: Context): Boolean =
      ContextCompat.checkSelfPermission(
          context,
          Manifest.permission.RECORD_AUDIO,
      ) == PackageManager.PERMISSION_GRANTED
  ```

### Task 5.2: Add permission state to `MainViewModel`

**Definition of Done**: `MainViewModel` exposes camera and microphone permission state flows and refreshes them.

#### Action 5.2.1: Add state flows and refresh logic

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/viewmodels/MainViewModel.kt`
- **What**: Add `_isCameraPermissionGranted` and `_isMicrophonePermissionGranted` state flows, update `refreshPermissionStatus()`.
- **Change**:
  - Add after `_isNotificationPermissionGranted`:
    ```kotlin
    private val _isCameraPermissionGranted = MutableStateFlow(false)
    val isCameraPermissionGranted: StateFlow<Boolean> = _isCameraPermissionGranted.asStateFlow()

    private val _isMicrophonePermissionGranted = MutableStateFlow(false)
    val isMicrophonePermissionGranted: StateFlow<Boolean> = _isMicrophonePermissionGranted.asStateFlow()
    ```
  - Add to `refreshPermissionStatus()` (after notification permission check, before `refreshStorageLocations()`):
    ```kotlin
    _isCameraPermissionGranted.value =
        PermissionUtils.isCameraPermissionGranted(context)
    _isMicrophonePermissionGranted.value =
        PermissionUtils.isMicrophonePermissionGranted(context)
    ```

### Task 5.3: Add string resources

**Definition of Done**: String resources for camera and microphone permission labels are added.

#### Action 5.3.1: Add strings to `strings.xml`

- **File**: `app/src/main/res/values/strings.xml`
- **What**: Add permission label strings after the existing `permission_grant` entry.
- **Change**: Add:
  ```xml
  <string name="permission_camera">Camera</string>
  <string name="permission_microphone">Microphone</string>
  ```

### Task 5.4: Update `PermissionsSection` composable

**Definition of Done**: `PermissionsSection` displays camera and microphone permission rows.

#### Action 5.4.1: Update `PermissionsSection` signature and content

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/components/PermissionsSection.kt`
- **What**: Add `isCameraPermissionGranted`, `isMicrophonePermissionGranted`, `onRequestCameraPermission`, and `onRequestMicrophonePermission` parameters. Add two new `PermissionRow` composables after the notification permission row.
- **Change**: Update function signature to add:
  ```kotlin
  isCameraPermissionGranted: Boolean,
  isMicrophonePermissionGranted: Boolean,
  onRequestCameraPermission: () -> Unit,
  onRequestMicrophonePermission: () -> Unit,
  ```
  Add after the notification `PermissionRow` + `Spacer`:
  ```kotlin
  Spacer(modifier = Modifier.height(8.dp))

  PermissionRow(
      label = stringResource(R.string.permission_camera),
      isEnabled = isCameraPermissionGranted,
      buttonText =
          if (isCameraPermissionGranted) {
              stringResource(R.string.permission_granted)
          } else {
              stringResource(R.string.permission_grant)
          },
      onAction = onRequestCameraPermission,
      actionEnabled = !isCameraPermissionGranted,
  )

  Spacer(modifier = Modifier.height(8.dp))

  PermissionRow(
      label = stringResource(R.string.permission_microphone),
      isEnabled = isMicrophonePermissionGranted,
      buttonText =
          if (isMicrophonePermissionGranted) {
              stringResource(R.string.permission_granted)
          } else {
              stringResource(R.string.permission_grant)
          },
      onAction = onRequestMicrophonePermission,
      actionEnabled = !isMicrophonePermissionGranted,
  )
  ```
  Update the `@Preview` composable to include new params with default values (`false` and `{}`). Keep the preview consistent with the existing style.

### Task 5.5: Update `HomeScreen` to accept and pass new permission callbacks

**Definition of Done**: `HomeScreen` accepts camera/microphone permission callbacks as parameters (following the existing pattern where `MainActivity` owns the launchers), collects permission state from ViewModel, and passes everything to `PermissionsSection`.

#### Action 5.5.1: Update `HomeScreen` composable

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/screens/HomeScreen.kt`
- **What**: Add `onRequestCameraPermission` and `onRequestMicrophonePermission` callback parameters to `HomeScreen` (following the existing `onRequestNotificationPermission` pattern). Collect camera/microphone permission state from ViewModel. Pass to `PermissionsSection`.
- **Change**: 
  - Update function signature (add after `onRequestNotificationPermission`):
    ```kotlin
    fun HomeScreen(
        onRequestNotificationPermission: () -> Unit = {},
        onRequestCameraPermission: () -> Unit = {},
        onRequestMicrophonePermission: () -> Unit = {},
        viewModel: MainViewModel = hiltViewModel(),
    )
    ```
  - Add state collection (after `isNotificationPermissionGranted`):
    ```kotlin
    val isCameraPermissionGranted by viewModel.isCameraPermissionGranted.collectAsStateWithLifecycle()
    val isMicrophonePermissionGranted by viewModel.isMicrophonePermissionGranted.collectAsStateWithLifecycle()
    ```
  - Pass to `PermissionsSection` (add after `onRequestNotificationPermission`):
    ```kotlin
    isCameraPermissionGranted = isCameraPermissionGranted,
    isMicrophonePermissionGranted = isMicrophonePermissionGranted,
    onRequestCameraPermission = onRequestCameraPermission,
    onRequestMicrophonePermission = onRequestMicrophonePermission,
    ```

### Task 5.6: Update `MainActivity` to create permission launchers

**Definition of Done**: `MainActivity` creates camera and microphone permission launchers and passes the request callbacks to `HomeScreen`, following the existing notification permission pattern.

#### Action 5.6.1: Add camera and microphone permission launchers to `MainActivity`

- **File**: `app/src/main/kotlin/com/danielealbano/androidremotecontrolmcp/ui/MainActivity.kt`
- **What**: Add `cameraPermissionLauncher` and `microphonePermissionLauncher` fields (following the existing `notificationPermissionLauncher` pattern), create request functions, pass callbacks to `HomeScreen`.
- **Change**:
  - Add fields (after `notificationPermissionLauncher`):
    ```kotlin
    private lateinit var cameraPermissionLauncher: ActivityResultLauncher<String>
    private lateinit var microphonePermissionLauncher: ActivityResultLauncher<String>
    ```
  - Register launchers in `onCreate()` (after `notificationPermissionLauncher` registration):
    ```kotlin
    cameraPermissionLauncher =
        registerForActivityResult(
            ActivityResultContracts.RequestPermission(),
        ) { _ ->
            viewModel.refreshPermissionStatus(this)
        }

    microphonePermissionLauncher =
        registerForActivityResult(
            ActivityResultContracts.RequestPermission(),
        ) { _ ->
            viewModel.refreshPermissionStatus(this)
        }
    ```
  - Pass callbacks to `HomeScreen` in `setContent`:
    ```kotlin
    HomeScreen(
        onRequestNotificationPermission = ::requestNotificationPermission,
        onRequestCameraPermission = ::requestCameraPermission,
        onRequestMicrophonePermission = ::requestMicrophonePermission,
    )
    ```
  - Add request functions (after `requestNotificationPermission()`):
    ```kotlin
    private fun requestCameraPermission() {
        cameraPermissionLauncher.launch(Manifest.permission.CAMERA)
    }

    private fun requestMicrophonePermission() {
        microphonePermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
    }
    ```

### Task 5.7: Run lint and verify

**Definition of Done**: All modified files pass linting.

#### Action 5.7.1: Run linting

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No new warnings or errors

#### Action 5.7.2: Run full unit tests

- **Command**: `./gradlew :app:test`
- **Expected**: All tests pass

---

## User Story 6: Documentation Updates

**Goal**: Update PROJECT.md, MCP_TOOLS.md, and ARCHITECTURE.md to document the new Camera Tools category.

### Acceptance Criteria
- [ ] `PROJECT.md` — MCP Tools Specification section includes Camera Tools (category 10) with tool table
- [ ] `PROJECT.md` — Permission Model includes CAMERA and RECORD_AUDIO
- [ ] `PROJECT.md` — Folder structure includes `services/camera/` and camera data models
- [ ] `PROJECT.md` — Default Configuration includes camera defaults
- [ ] `MCP_TOOLS.md` — New section "10. Camera Tools" with full JSON-RPC schemas, examples, and error cases for all 6 tools
- [ ] `MCP_TOOLS.md` — Overview table updated to include Camera Tools
- [ ] `MCP_TOOLS.md` — Total tool count updated (39 → 45)
- [ ] `ARCHITECTURE.md` — Component diagram updated with CameraProvider
- [ ] `ARCHITECTURE.md` — Permission Model table includes CAMERA and RECORD_AUDIO
- [ ] Linting passes on markdown (no build impact)

### Task 6.1: Update `PROJECT.md`

**Definition of Done**: PROJECT.md includes Camera Tools documentation.

#### Action 6.1.1: Add Camera Tools to MCP Tools Specification

- **File**: `docs/PROJECT.md`
- **What**: Add section "10. Camera Tools (6 tools)" after the App Management Tools section. Include tool table with columns: Tool, Description, Required Params, Optional Params.
- **Content**: Table with all 6 tools and their parameters, following the same format as existing sections. Update total tool count from 39 to 45. Add error descriptions.

#### Action 6.1.2: Add camera permissions to Permission Model

- **File**: `docs/PROJECT.md`
- **What**: Add CAMERA and RECORD_AUDIO to the permissions section.

#### Action 6.1.3: Update folder structure

- **File**: `docs/PROJECT.md`
- **What**: Add `services/camera/` entries (CameraProvider.kt, CameraProviderImpl.kt, ServiceLifecycleOwner.kt) and data model entries (CameraInfo.kt, CameraResolution.kt) to the folder structure section.

#### Action 6.1.4: Add camera defaults to Default Configuration

- **File**: `docs/PROJECT.md`
- **What**: Add camera defaults section: default resolution 720p, default quality 80, default flash mode auto, max video duration 30s, default audio true.

### Task 6.2: Update `MCP_TOOLS.md`

**Definition of Done**: Full MCP_TOOLS.md documentation for all 6 camera tools.

#### Action 6.2.1: Update overview and table of contents

- **File**: `docs/MCP_TOOLS.md`
- **What**: Add Camera Tools to the overview table (category 10) and Table of Contents. Update total tool count.

#### Action 6.2.2: Add Camera Tools section

- **File**: `docs/MCP_TOOLS.md`
- **What**: Add "## 10. Camera Tools" section after App Management Tools. Include for each tool:
  - Tool name and description
  - Input schema (JSON)
  - Parameter table
  - Request example (JSON)
  - Response example (JSON)
  - Error cases
- **Tools to document**: `android_list_cameras`, `android_list_camera_photo_resolutions`, `android_list_camera_video_resolutions`, `android_take_camera_photo`, `android_save_camera_photo`, `android_save_camera_video`

### Task 6.3: Update `ARCHITECTURE.md`

**Definition of Done**: Architecture documentation includes camera service components and permissions.

#### Action 6.3.1: Update component diagram

- **File**: `docs/ARCHITECTURE.md`
- **What**: Add `CameraProvider` to the component diagram in the `StorageSvc` subgraph (or create a new `CameraSvc` subgraph), add connection from `SDK` to camera service.

#### Action 6.3.2: Update permission model table

- **File**: `docs/ARCHITECTURE.md`
- **What**: Add CAMERA (Runtime) and RECORD_AUDIO (Runtime) to the Permission Model table.

---

## User Story 7: Final Verification

**Goal**: Complete end-to-end verification that everything is implemented correctly, builds, passes all tests, and documentation is consistent.

### Acceptance Criteria
- [ ] Full build succeeds: `./gradlew assembleDebug`
- [ ] All linting passes: `./gradlew ktlintCheck detekt`
- [ ] All unit tests pass: `./gradlew :app:test`
- [ ] Camera tool unit tests pass: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.mcp.tools.CameraToolsTest"`
- [ ] Camera provider unit tests pass: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.services.camera.CameraProviderImplTest"`
- [ ] Camera integration tests pass: `./gradlew :app:testDebugUnitTest --tests "com.danielealbano.androidremotecontrolmcp.integration.CameraToolsIntegrationTest"`
- [ ] All existing tests still pass (no regressions)
- [ ] `AndroidManifest.xml` has CAMERA and RECORD_AUDIO permissions and optional features
- [ ] `AppModule.kt` has CameraProvider binding
- [ ] `McpServerService.kt` injects CameraProvider and registers camera tools
- [ ] `McpIntegrationTestHelper.kt` has CameraProvider in MockDependencies
- [ ] `PermissionsSection.kt` shows camera and microphone permission rows
- [ ] `MainViewModel.kt` has camera and microphone permission state flows
- [ ] `PermissionUtils.kt` has camera and microphone permission check methods
- [ ] `PROJECT.md` documents camera tools, permissions, defaults, and folder structure
- [ ] `MCP_TOOLS.md` documents all 6 camera tools with schemas and examples
- [ ] `ARCHITECTURE.md` includes camera service in diagram and permission table
- [ ] No TODOs, no commented-out code, no placeholder implementations
- [ ] Tool count in PROJECT.md and MCP_TOOLS.md is updated to 45

### Task 7.1: Full build verification

#### Action 7.1.1: Clean build

- **Command**: `./gradlew clean assembleDebug`
- **Expected**: BUILD SUCCESSFUL

### Task 7.2: Full lint verification

#### Action 7.2.1: Run all linters

- **Command**: `./gradlew ktlintCheck detekt`
- **Expected**: No warnings or errors

### Task 7.3: Full test verification

#### Action 7.3.1: Run all tests

- **Command**: `./gradlew :app:test`
- **Expected**: All tests pass

### Task 7.4: Documentation consistency check

#### Action 7.4.1: Verify tool count

- **What**: Check that PROJECT.md, MCP_TOOLS.md overview, and the actual number of registered tools all agree (45 tools in 10 categories).

#### Action 7.4.2: Verify all new files are listed in PROJECT.md folder structure

- **What**: Cross-reference the "Files Impacted" table in this plan with the folder structure section in PROJECT.md.

### Task 7.5: Ground-up review of all changes

**Definition of Done**: Every single file changed or created in this plan is re-read and verified against the plan requirements.

#### Action 7.5.1: Re-read and verify all new files

- **What**: Read each new file created during implementation and verify:
  1. It matches the plan specification exactly
  2. No TODOs or placeholder code
  3. Proper error handling (try/catch/finally, resource cleanup)
  4. Consistent coding style with existing codebase
  5. KDoc on all public classes and methods
  6. Proper imports (no wildcard imports, no unused imports)
- **Files to verify**:
  - `CameraInfo.kt`
  - `CameraResolution.kt`
  - `CameraProvider.kt`
  - `ServiceLifecycleOwner.kt`
  - `CameraProviderImpl.kt`
  - `CameraTools.kt`
  - `ServiceLifecycleOwnerTest.kt`
  - `CameraProviderImplTest.kt`
  - `CameraToolsTest.kt`
  - `CameraToolsIntegrationTest.kt`

#### Action 7.5.2: Re-read and verify all modified files

- **What**: Read each modified file and verify:
  1. Changes are minimal and correct
  2. No accidental deletions or modifications to existing code
  3. New additions follow the existing patterns in the file
  4. All new parameters are threaded through correctly (e.g., CameraProvider from DI → Service → registerAllTools → tool handlers)
- **Files to verify**:
  - `libs.versions.toml`
  - `app/build.gradle.kts`
  - `AndroidManifest.xml`
  - `strings.xml`
  - `AppModule.kt`
  - `McpServerService.kt`
  - `PermissionUtils.kt`
  - `MainViewModel.kt`
  - `PermissionsSection.kt`
  - `HomeScreen.kt`
  - `MainActivity.kt`
  - `McpIntegrationTestHelper.kt`
  - `FileOperationProvider.kt`
  - `FileOperationProviderImpl.kt`
  - `FileOperationProviderTest.kt`
  - `PROJECT.md`
  - `MCP_TOOLS.md`
  - `ARCHITECTURE.md`

#### Action 7.5.3: Verify integration test helper completeness

- **What**: Verify that `McpIntegrationTestHelper` registers camera tools and that all existing tests still work with the updated `MockDependencies` (the new `cameraProvider` field must not break existing test code since `createMockDependencies()` creates it automatically).

---

**End of Plan 27**
