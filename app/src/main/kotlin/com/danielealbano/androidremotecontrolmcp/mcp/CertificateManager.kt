package com.danielealbano.androidremotecontrolmcp.mcp

import android.content.Context
import android.util.Log
import com.danielealbano.androidremotecontrolmcp.data.model.CertificateSource
import com.danielealbano.androidremotecontrolmcp.data.model.ServerConfig
import dagger.hilt.android.qualifiers.ApplicationContext
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.asn1.x509.GeneralName
import org.bouncycastle.asn1.x509.GeneralNamesBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.math.BigInteger
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.SecureRandom
import java.security.cert.X509Certificate
import java.util.Calendar
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton
import javax.security.auth.x500.X500Principal

/**
 * Manages SSL certificates for the MCP server when HTTPS is enabled.
 *
 * Supports two modes:
 * - **Auto-generated**: Creates a self-signed RSA 2048-bit X.509 certificate
 *   with CN and SAN matching the configured hostname. Valid for 1 year.
 * - **Custom**: Imports a user-provided .p12/.pfx certificate file.
 *
 * Certificates are stored in app-private storage ([Context.getFilesDir]).
 */
@Singleton
class CertificateManager
    @Inject
    constructor(
        @param:ApplicationContext private val context: Context,
    ) {
        /**
         * Returns the KeyStore for the server's HTTPS mode, loading an existing one
         * or generating a new self-signed certificate if none exists.
         *
         * @return The [KeyStore] configured with the server certificate and private key.
         */
        fun getOrCreateKeyStore(config: ServerConfig): KeyStore =
            when (config.certificateSource) {
                CertificateSource.AUTO_GENERATED -> getOrCreateAutoGeneratedKeyStore(config.certificateHostname)
                CertificateSource.CUSTOM ->
                    loadCustomKeyStore()
                        ?: getOrCreateAutoGeneratedKeyStore(config.certificateHostname)
            }

        /**
         * Generates a new self-signed certificate with the given hostname.
         *
         * Overwrites any existing auto-generated keystore.
         *
         * @param hostname The hostname for the certificate CN and SAN.
         * @return The [KeyStore] containing the new certificate.
         */
        fun generateSelfSignedCertificate(hostname: String): KeyStore {
            Log.i(TAG, "Generating self-signed certificate for hostname: $hostname")

            val keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM)
            keyPairGenerator.initialize(KEY_SIZE, SecureRandom())
            val keyPair = keyPairGenerator.generateKeyPair()

            val notBefore = Date()
            val calendar = Calendar.getInstance()
            calendar.time = notBefore
            calendar.add(Calendar.YEAR, CERTIFICATE_VALIDITY_YEARS)
            val notAfter = calendar.time

            val serialNumber = BigInteger(SERIAL_NUMBER_BIT_LENGTH, SecureRandom())
            val subjectDN = X500Principal("CN=$hostname")

            // Generate self-signed X.509 certificate using Bouncy Castle
            val certBuilder =
                JcaX509v3CertificateBuilder(
                    subjectDN,
                    serialNumber,
                    notBefore,
                    notAfter,
                    subjectDN,
                    keyPair.public,
                )

            // Add Subject Alternative Name (SAN) extension for the hostname
            val sanBuilder = GeneralNamesBuilder()
            sanBuilder.addName(GeneralName(GeneralName.dNSName, hostname))
            // Also add localhost and 127.0.0.1 as SANs for local development
            sanBuilder.addName(GeneralName(GeneralName.dNSName, "localhost"))
            sanBuilder.addName(GeneralName(GeneralName.iPAddress, "127.0.0.1"))
            certBuilder.addExtension(
                Extension.subjectAlternativeName,
                false,
                sanBuilder.build(),
            )

            // Sign the certificate with SHA256withRSA
            val signer =
                JcaContentSignerBuilder(SIGNATURE_ALGORITHM)
                    .build(keyPair.private)
            val certHolder = certBuilder.build(signer)
            val cert =
                JcaX509CertificateConverter()
                    .setProvider(BouncyCastleProvider())
                    .getCertificate(certHolder)

            val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
            keyStore.load(null, getKeyStorePassword())
            keyStore.setKeyEntry(KEY_ALIAS, keyPair.private, getKeyStorePassword(), arrayOf(cert))

            val keystoreFile = getAutoGeneratedKeystoreFile()
            FileOutputStream(keystoreFile).use { fos ->
                keyStore.store(fos, getKeyStorePassword())
            }

            Log.i(TAG, "Self-signed certificate generated and stored at: ${keystoreFile.absolutePath}")
            return keyStore
        }

        /**
         * Imports a custom .p12/.pfx certificate.
         *
         * @param certificateBytes The raw bytes of the .p12/.pfx file.
         * @param password The password to decrypt the certificate file.
         * @return [Result.success] with the [KeyStore] if import succeeds,
         *         [Result.failure] with an appropriate exception if it fails.
         */
        @Suppress("TooGenericExceptionCaught")
        fun importCustomCertificate(
            certificateBytes: ByteArray,
            password: String,
        ): Result<KeyStore> =
            try {
                val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
                keyStore.load(certificateBytes.inputStream(), password.toCharArray())

                // Validate certificate is not expired
                val aliases = keyStore.aliases()
                while (aliases.hasMoreElements()) {
                    val alias = aliases.nextElement()
                    val cert = keyStore.getCertificate(alias)
                    if (cert is X509Certificate) {
                        cert.checkValidity()
                    }
                }

                // Re-store the custom keystore with the app's auto-generated password.
                // This ensures loadCustomKeyStore() can load it consistently using
                // getKeyStorePassword(), regardless of the original import password.
                val keystoreFile = getCustomKeystoreFile()
                FileOutputStream(keystoreFile).use { fos ->
                    keyStore.store(fos, getKeyStorePassword())
                }

                Log.i(TAG, "Custom certificate imported successfully")
                Result.success(keyStore)
            } catch (e: java.security.cert.CertificateExpiredException) {
                Log.w(TAG, "Custom certificate import failed: certificate expired", e)
                Result.failure(IllegalArgumentException("Certificate is expired", e))
            } catch (e: java.io.IOException) {
                Log.w(TAG, "Custom certificate import failed: wrong password or invalid file", e)
                Result.failure(IllegalArgumentException("Wrong password or invalid certificate file", e))
            } catch (e: Exception) {
                Log.e(TAG, "Custom certificate import failed", e)
                Result.failure(e)
            }

        /**
         * Returns the keystore password. Generates and persists one if none exists.
         *
         * The password is stored in a separate file in app-private storage.
         */
        fun getKeyStorePassword(): CharArray {
            val passwordFile = File(context.filesDir, KEYSTORE_PASSWORD_FILENAME)
            return if (passwordFile.exists()) {
                passwordFile.readText().toCharArray()
            } else {
                val password = generatePassword()
                passwordFile.writeText(String(password))
                password
            }
        }

        @Suppress("TooGenericExceptionCaught")
        private fun getOrCreateAutoGeneratedKeyStore(hostname: String): KeyStore {
            val keystoreFile = getAutoGeneratedKeystoreFile()
            return if (keystoreFile.exists()) {
                val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
                FileInputStream(keystoreFile).use { fis ->
                    keyStore.load(fis, getKeyStorePassword())
                }
                keyStore
            } else {
                generateSelfSignedCertificate(hostname)
            }
        }

        @Suppress("TooGenericExceptionCaught")
        private fun loadCustomKeyStore(): KeyStore? {
            val keystoreFile = getCustomKeystoreFile()
            if (!keystoreFile.exists()) return null

            return try {
                val keyStore = KeyStore.getInstance(KEYSTORE_TYPE)
                FileInputStream(keystoreFile).use { fis ->
                    keyStore.load(fis, getKeyStorePassword())
                }
                keyStore
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load custom keystore, falling back to auto-generated", e)
                null
            }
        }

        private fun getAutoGeneratedKeystoreFile(): File = File(context.filesDir, KEYSTORE_FILENAME)

        private fun getCustomKeystoreFile(): File = File(context.filesDir, CUSTOM_KEYSTORE_FILENAME)

        private fun generatePassword(): CharArray {
            val bytes = ByteArray(PASSWORD_LENGTH)
            SecureRandom().nextBytes(bytes)
            return bytes.joinToString("") { "%02x".format(it) }.toCharArray()
        }

        companion object {
            private const val TAG = "MCP:CertificateManager"
            const val KEY_ALIAS = "mcp-server"
            const val KEYSTORE_FILENAME = "mcp_keystore.p12"
            const val CUSTOM_KEYSTORE_FILENAME = "mcp_custom_keystore.p12"
            const val KEYSTORE_PASSWORD_FILENAME = "mcp_keystore_password"
            const val KEYSTORE_TYPE = "PKCS12"
            const val KEY_ALGORITHM = "RSA"
            const val KEY_SIZE = 2048
            const val SIGNATURE_ALGORITHM = "SHA256withRSA"
            const val CERTIFICATE_VALIDITY_YEARS = 1
            const val SERIAL_NUMBER_BIT_LENGTH = 128
            const val PASSWORD_LENGTH = 32
        }
    }
